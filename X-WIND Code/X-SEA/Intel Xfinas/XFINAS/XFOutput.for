C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
      SUBROUTINE ININUMB
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	---------------------------
C	---------------------------

      COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM
      COMMON /NUMB2/ IDOFB(9)
      
      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

C	GETTING KCSAL (CONSTRUCTION STAGE INDEX 0=NOT INCLUDE 1=INCLUDE)
	COMMON /LINEAT/ KTRAF,KEATH,KCSAL,KOFFL,KSPEC,KDESIGN,KFATM,KFATJ,KFATL,KFAST,KOREV !SONGSAK AUG2007 RESPONSE SPECTRUM FOR ISOLOP 1 !SONGSAK AUG2007 RESPONSE SPECTRUM FOR ISOLOP 1

C	GRAVTITY DIRECTION
	COMMON /MGRAV/ NGRAV
      
      COMMON /CONSTINT/ MTOTI(10),NCONI(5000),ICONDT(1)
      COMMON /CONSTREL/ MTOTR(10),NCONR(5000),RCONDT(1)

C	INITIALIZE I/O LIST AND UNIT
	CALL INIOUNIT

C	FILE FOR PRINTING  NOT=ISO
	CALL INTFILL('%IOL',NOT,1,3,0)

C	STORE NUMB COMMON
	NEQ = 0 !EQUATION
	NEQR= 0 !RESTRAINT EQUA
	NWK = 0 !STIFFNESS SIZE
	CALL DEFNINT('%NUB',KUMB ,1,20)
	CALL INTFILL('%NUB',NSN  ,1,1 ,1)
	CALL INTFILL('%NUB',NSF  ,1,2 ,1)
	CALL INTFILL('%NUB',NLA  ,1,3 ,1)
	CALL INTFILL('%NUB',NSC  ,1,4 ,1)
	CALL INTFILL('%NUB',NEG  ,1,5 ,1)
	CALL INTFILL('%NUB',NEQ  ,1,6 ,1)  !TO STORE NEQ  FOR CONSTRUCTION STAGE  (SEE ALSO EQNMBR)
	CALL INTFILL('%NUB',NEQR ,1,7 ,1)  !TO STORE NEQR FOR CONSTRUCTION STAGE  (SEE ALSO EQNMBR)
	CALL INTFILL('%NUB',NWK  ,1,8 ,1)  !TO STORE NWK  FOR CONSTRUCTION STAGE  (SEE ALSO STFADR)
	CALL INTFILL('%NUB',NGRAV,1,9 ,1)  !GRAVITY DIRECTION
	CALL INTFILL('%NUB',LEL  ,1,10,1)  !LEL  ELEMENT GROUP POINTER
	CALL INTFILL('%NUB',NLS  ,1,11,1)  !NUMBER OF LOCAL SUPPORT
	CALL INTFILL('%NUB',LCS  ,1,12,1)  !NUMBER OF LOAD CASE
      
      NGGEO = 0 !UPDATE MAX VALUE AGAIn IN SUB. INIGRPF ... SONGSAK OCT2019
	CALL INTFILL('%NUB',NGGEO,1,13,1)  !NUMBER OF GEOMETRIC GROUP ... ADDED BY SONGSAK OCT2019

C	STORE IDOF
	CALL DEFNINT('%DOF',LDOF,1,9 )
	DO I = 1,9
	CALL INTFILL('%DOF',IDOF(I),1,I,1)
	ENDDO
	
C	STORE IDOFB
	CALL DEFNINT('%DOB',LDOB,1,9 )
	DO I = 1,9
	CALL INTFILL('%DOB',IDOFB(I),1,I,1)
      ENDDO

C	NODAL COORDINATES FOR TUEY .. SONGSAK OCT2019
      CALL DEFNREL('@XYZ',KXYZ,NSC,NSN) 
      CALL STORXYZ (NSC,NSN) 
      
C	STORE FIXED SUPPORT ... SONGSAK OCT2019
      CALL STORLRID
	
	IF(ISOLOP.EQ.1) THEN
	
C	------------------------------------------------------
C	THESE BLOCKS ARE FOR CONSTRUCTION STAGE ANALYSIS ONLY
C	------------------------------------------------------
	IF(KCSAL.EQ.1) THEN

C	NODAL COORDINATES
      CALL DEFNREL('$XYZ',KXYZ,NSC,NSN) 
      CALL  INPXYZ(RCONDT(KXYZ),NSC,NSN)


C	LOCAL AXIS
	NLX = 9         !3 OF LOCAL AXIS VECTOR 
      CALL DEFNREL('$LAX',KLAX,NLX,NLA)
      CALL  INPLAX(RCONDT(KLAX),NLX,NLA)


C	NEXT FOR CONSTRUCTION SATAGE ANALYSIS

C	EQUATION NUMBER FOR EACH NODE (FULLY FREE STRUCTURE NO SUPPORT RESTRAINT HERE)
      CALL DEFNINT('$LID',KLID,NSF,NSN)  
      CALL  INPLID(ICONDT(KLID),NSF,NSN)

C	NODE SEQUENCE  (CAN REMOVE LATER)
      CALL DEFNINT('$SEQ',KSEQ,1,NSN)
      CALL  INPSEQ(ICONDT(KSEQ),NSN)

C	------------------------------------------------------
	ENDIF
C	------------------------------------------------------

      ELSEIF(ISOLOP.EQ.19) THEN  
      
C	------------------------------------------------------
C	THESE BLOCKS ARE FOR CONSTRUCTION STAGE ANALYSIS ONLY	

C	NODAL COORDINATES
      CALL DEFNREL('$XYZ',KXYZ,NSC,NSN) 
      CALL  INPXYZ(RCONDT(KXYZ),NSC,NSN)

C	LOCAL AXIS
	NLX = 9         !3 OF LOCAL AXIS VECTOR 
      CALL DEFNREL('$LAX',KLAX,NLX,NLA)
      CALL  INPLAX(RCONDT(KLAX),NLX,NLA)

C	NEXT FOR CONSTRUCTION SATAGE ANALYSIS

C	EQUATION NUMBER FOR EACH NODE (FULLY FREE STRUCTURE NO SUPPORT RESTRAINT HERE)
      CALL DEFNINT('$LID',KLID,NSF,NSN)  
      CALL  INPLID(ICONDT(KLID),NSF,NSN)

C	NODE SEQUENCE  (CAN REMOVE LATER)
      CALL DEFNINT('$SEQ',KSEQ,1,NSN)
      CALL  INPSEQ(ICONDT(KSEQ),NSN)
	
C	------------------------------------------------------       
      ENDIF


	RETURN
	END

C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
      SUBROUTINE INIOUNIT
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)

      COMMON /INOU/ ITI,ITO,ISO,NDATI,NPLOT,NKFAC,NELEM,
     1              IFPR(10),IFPL(10)

	DIMENSION UTOL(9)

C	---------------------------------------------------------------------
C     IO LIST
C	---------------------------------------------------------------------                                         
      CALL DEFNINT('%IOL',IOLS,1,20)
      CALL INTZERO('%IOL')
	CALL INTFILL('%IOL',ITI,1,1,1)  !DATIN.DAT FILE
	CALL INTFILL('%IOL',ITO,1,2,1)  !SCREEN
	CALL INTFILL('%IOL',ISO,1,3,1)  !OUTPUT.OUT
	IGO = 101 !********
	CALL INTFILL('%IOL',IGO,1,4,1)  !GIDOUT.FLAVIA



C	---------------------------------------------------------------------
C     UNIT LIST
C	---------------------------------------------------------------------  
C	UNIT FLAG
      CALL DEFNINT('UNIT',IUNT,1,6)
      CALL INTZERO('UNIT')
	CALL FREBUF
	CALL FREECH
      CALL FREINT('F',IU,1) !FORC
	CALL INTFILL('UNIT',IU,1,1,1)
      CALL FREINT('L',IU,1) !LENG
	CALL INTFILL('UNIT',IU,1,2,1)
      CALL FREINT('R',IU,1) !ROTA
	CALL INTFILL('UNIT',IU,1,3,1)
      CALL FREINT('M',IU,1) !MASS
	CALL INTFILL('UNIT',IU,1,4,1)
      CALL FREINT('T',IU,1) !TIME
	CALL INTFILL('UNIT',IU,1,5,1)
      CALL FREINT('D',IU,1) !TEMP
	CALL INTFILL('UNIT',IU,1,6,1)

C	---------------------------------------------------------------------
C     OUTPUT CONTROL
C	---------------------------------------------------------------------  
      CALL DEFNINT('OUTC',KOUTC,1,20)
      CALL INTZERO('OUTC')
	CALL FREBUF
      CALL FREINT('P',IPOS,1) !upper bound   max
      CALL FREINT('N',INEG,1) !lower bound   min
      
      IF(IPOS.EQ.0.AND.INEG.EQ.0) THEN
      IPOS = 1
      INEG = 1
      ENDIF
       
      CALL INTFILL('OUTC',IPOS,1,1,1)
      CALL INTFILL('OUTC',INEG,1,2,1)


	RETURN
	END

C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE INIOUT1
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------

	CALL DEFNINT('NOUT',NOUT,1,200)   !OUTPUT MAPPING DATA      
	CALL INTZERO('NOUT')

	CALL DEFNINT('PGAS',NGAS,20,20)    !ELEMENT GAUSS POINT PRINTING FLAG ISTYP,ITYPE
	CALL INTZERO('PGAS')
	
	NFIL = 803 !ELEMENT GROUP STORAGE FILE
	CALL INTFILL('NOUT',NFIL,1,3,1)  
C	CALL INIOPER(NFIL,0,0.0D0,'NONE','NEWF')  !DIRECT ACCESS  ***OPEN IN GRPFILE
	
	CALL INIGRP

C     CALCULATE OUTPUT STORAGE SIZE	
	CALL OUTLENG
	
	NFIL = 800 !LOAD CASE OUTPUT FILE
	CALL INTFILL('NOUT',NFIL,1,1,1) 
	CALL INIOPER(NFIL,0,0.0D0,'NONE','NEWF')  !DIRECT ACCESS

	NFIL = 801 !LOAD COMBINATION INPUT
	CALL INTFILL('NOUT',NFIL,1,2,1)    
	CALL INIOPER(NFIL,0,0.0D0,'NONE','NEWS')  !SEQUENTIAL


	NFIL = 850 !LOAD COMBINATION OUTPUT FILE
	CALL INTFILL('NOUT',NFIL,1,4,1)     
	CALL INIOPER(NFIL,0,0.0D0,'NONE','NEWF')  !DIRECT ACCESS

	CALL DEFNINT('NPRN',NPRN,1,13)    !OUTPUT PRINTING FLAG     (POINTER 11 IS FOR CONTROL TOT POS NEG) (POINTER 12 IS FOR CONTROL STANDARD OF COMBINATION)  (POINTER 13 IS FOR PRINT ALL OR JUST ONE STEP)
	CALL INTZERO('NPRN')
      
C     ELEMENT GROUP FILE
      CALL GRPFILE
C     INITIALZE ELEMENT FILE RECORD      
      CALL INIGRPF

      RETURN
      END
C


C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE GRPFILE (OPT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*1 NAMEI(4)
      CHARACTER*3 OPT
      DIMENSION   INAME(4)
      COMMON /ELEM/ NAME(2),ITYPE,ISTYP,NLOPT,MTMOD,NSINC,ITOLEY,
     1              NELE,NMPS,NGPS,NMP,NGP,NNM,NEX,NCO,NNF,NWG,NEFC,
     2              NPT,NWA,NWS,KEG,MEL,NNO,NEF,NELTOT,NMV,MTYP,ISECT
      COMMON/OFFSHORE_CASE/ LGEN,IOFFL,IORI_OFFSHORE
      COMMON /TIME/ DDT,CTIM,NINC
C     OPEN FILE FOR EACH ELEM GROUP

C	CALLING NEG
	CALL INTFILL('%NUB',NEG,1,5 ,0)
	
C	----------------------------------------
C	LOOP OVER ELEMENT GROUP 
C	----------------------------------------	
	DO 2500 IEG = 1,NEG
	
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',N2   ,2 ,IEG,0) !
	CALL INTFILL('OGRF',N3   ,3 ,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL INTFILL('OGRF',N4   ,4 ,IEG,0) !FOR STORING THE CONNECTIVITY
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !ELEMENT GROUP OUTPUT FILE SEE -- GRPOPER
	CALL INTFILL('OGRF',NFL2 ,12,IEG,0) !FOR FIXEND FORCES
	CALL INTFILL('OGRF',NFL3 ,13,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL INTFILL('OGRF',NFL4 ,14,IEG,0) !FOR STORING THE CONNECTIVITY
      CALL INTFILL('OGRF',NFL5 ,15,IEG,0) !NEW INDICATOR FOR NEW ARRAY OF SAVING LOCAL STRESS OF SOLID-SHELL(P) BY BJ
      CALL INTFILL('OGRF',NFL6 ,16,IEG,0) !OFFSHORE LOAD CASE BY TOEY
      CALL INTFILL('OGRF',NFL10 ,20,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM OFFSHORE LOAD

      

	CALL DIROPEN(NFL1,2*N1)                   !ELEMENT GROUP OUTPUT FILE SEE -- GRPOPER
	CALL DIROPEN(NFL2,2*N2)                   !FOR FIXEND FORCES
	IF(ITYPE.EQ.5) CALL DIROPEN(NFL3,2*N3)    !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL DIROPEN(NFL4,2*N4)                   !FOR STORING THE CONNECTIVITY  

      CALL DIROPEN(NFL5,2*N1)                   !NEW INDICATOR FOR NEW ARRAY OF SAVING LOCAL STRESS OF SOLID-SHELL(P) BY BJ
      CALL DIROPEN(NFL6,2*N2)                   !OFFSHORE LOAD TUEY  
      IF(ITYPE.EQ.5) CALL DIROPEN(NFL10,2*N3)    !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM OFFSHORE LOAD
   
      
2500	CONTINUE



	RETURN
	END
C	=======================================================================
C	=== NEW OUTPUT ========================== TOEY OCT2021 =============
C	=======================================================================
	SUBROUTINE DIROPEN_OFFSHORE_BINARY
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*1 NAMEI(4)
      CHARACTER*3 OPT
      DIMENSION   INAME(4)
      COMMON /ELEM/ NAME(2),ITYPE,ISTYP,NLOPT,MTMOD,NSINC,ITOLEY,
     1              NELE,NMPS,NGPS,NMP,NGP,NNM,NEX,NCO,NNF,NWG,NEFC,
     2              NPT,NWA,NWS,KEG,MEL,NNO,NEF,NELTOT,NMV,MTYP,ISECT
      COMMON/OFFSHORE_CASE/ LGEN,IOFFL,IORI_OFFSHORE
      COMMON /TIME/ DDT,CTIM,NINC

      CALL OFFSHSTEP(TIME,ITIME,NTIME,'CALT') 
      CALL INTFILL('OGRF',NFL7 ,17,1,0) !
      CALL INTFILL('OGRF',NFL8 ,18,1,0) !
      CALL INTFILL('OGRF',NFL9 ,19,1,0) !
      IF (IOFFL.EQ.0) IOFFL_OPEN = 1D0
      IF (IOFFL.NE.0) IOFFL_OPEN = IOFFL
      NREC = 200D0
      CALL DIROPEN(NFL7,NREC)        
      CALL DIROPEN(NFL8,NREC)         
      CALL DIROPEN(NFL9,NREC)



	RETURN
	END

C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE INIGRPF
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     INITIALIZE ELEMENT FILE
      CHARACTER*1 NAMEI(4)
      DIMENSION   INAME(4)

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON /CONSTINT/ MTOTI(10),NCONI(5000),ICONDT(1)
      COMMON /CONSTREL/ MTOTR(10),NCONR(5000),RCONDT(1)

      COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM
	COMMON /SPBC/ NSS,NLSS
      COMMON /MGLENK/ NGLELM,NGLSET,LNKLEN,LNKWRK,LNKFRE,LEKNOD(5000) 

      COMMON /ELEM/ NAME(2),ITYPE,ISTYP,NLOPT,MTMOD,NSINC,ITOLEY,
     1              NELE,NMPS,NGPS,NMP,NGP,NNM,NEX,NCO,NNF,NWG,NEFC,
     2              NPT,NWA,NWS,KEG,MEL,NNO,NEF,NELTOT,NMV,MTYP,ISECT
      COMMON /GAUS/ GLOC(10,10),GWT(10,10),NGR,NGS,NGT
	COMMON /GiDEle/ LGID

	COMMON /BF_SMOTH/ NP_SMH

      COMMON A(9000000),IA(9000000)

      COMMON /LOCO/ LOP,LOS,LSS,LSS2,LSS3,LHG,LHGN

	DIMENSION NPM(10),NPI(10)
      ALLOCATABLE LEST(:),AF1(:)
      ALLOCATABLE AF2(:) ! NEW WORKING ARRAY BY BJ

C	------------------------
C	ELEMENT GROUP LEVEL
C	------------------------

	CALL LOCATN('PGAS',KGAS,NN1,NN2,1)  !ELEMENT GAUSS POINT PRINTING FLAG ISTYP,ITYPE

C	CALLING NEG
	CALL INTFILL('%NUB',NEG,1,5 ,0)
	CALL INTFILL('%NUB',LEL,1,10,0)  !LEL  ELEMENT GROUP POINTER

	ALLOCATE(LEST(2*NEG))
	DO II = 1,2*NEG
	LEST(II) = IA(LEL+II-1)
	ENDDO

C	----------------------------------------
C	LOOP OVER ELEMENT GROUP 
C	----------------------------------------	
	DO 2500 IEG = 1,NEG
	NELEMI = 10 + IEG
      NELEMA = 30 + IEG
      REWIND NELEMI
      REWIND NELEMA
C      READ (NELEMI) (IA(NLNU),NLNU=LNU,LNU + LEST(IEG)-1)
C      READ (NELEMA) ( A(NLNU),NLNU=LMP,LMP + LEST(IEG+NEG)-1)
      READ (NELEMI) IA(LNU:LNU + LEST(IEG)-1)
      READ (NELEMA)  A(LMP:LMP + LEST(IEG+NEG)-1)
      CALL MOVLEV (2)
	
      

C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',MGAS ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',N2   ,2 ,IEG,0) !
	CALL INTFILL('OGRF',N3   ,3 ,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL INTFILL('OGRF',N4   ,4 ,IEG,0) !FOR STORING THE CONNECTIVITY
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !
	CALL INTFILL('OGRF',NFL2 ,12,IEG,0) !FOR FIXEND FORCES
	CALL INTFILL('OGRF',NFL3 ,13,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL INTFILL('OGRF',NFL4 ,14,IEG,0) !FOR STORING THE CONNECTIVITY
      CALL INTFILL('OGRF',NFL5 ,15,IEG,0) !NEW INDICATOR FOR NEW ARRAY OF SAVING LOCAL STRESS OF SOLID-SHELL(P) BY BJ      
      CALL INTFILL('OGRF',NFL6 ,16,IEG,0) !OFFSHORE LOAD CASE BY TOEY 
      CALL INTFILL('OGRF',NFL10 ,20,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRA
	

      
      ALLOCATE(AF1(N1))
      AF1(1:N1) = 0.0D0
      ALLOCATE(AF2(N1)) ! NEW WORKING ARRAY BY BJ
      AF2(1:N1) = 0.0D0
      
	DO 2000 IEL = 1,NELE

      WRITE(NFL1,REC=IEL) AF1(1:N1)
      
      WRITE(NFL5,REC=IEL) AF2(1:N1)
      
	IGM = IA(LGID+IEL-1)
	IF(ITYPE.EQ.17) IGM = 0	!TENDON

C	STORE GID ELEMENT MAPPING DATA
	CALL INTFILL('OGDM',IEG,1,IGM,1)
	CALL INTFILL('OGDM',IEL,2,IGM,1)

C     --------------------------------    
      IGST = IA(LGS+IEL-1)
	CALL INTFILL('OGDM',IGST,3,IGM,1)  !STORE GEOMETRIC SET INDEX
C     --------------------------------      
	CALL INTFILL('%NUB',NGGEO,1,13,0)  !CALL MAX. NUMBER OF GEOMETRIC SET ... ADDED BY SONGSAK OCT2019      
      IF(IGST.GT.NGGEO) THEN
      CALL INTFILL('%NUB',IGST ,1,13,1)  !UPDATE MAX NUMBER OF GEOMETRIC GROUP SET 
      ENDIF
C     --------------------------------  
      
      IF(IGM.NE.0) CALL WRITCON(IGM,IEL,IA(LCN),NNM,NEF,NFL4)    !FOR STORING THE CONNECTIVITY (USE FOR STRESS AVERAGE)
      
      !DO ILC = 1,LCS
	!CALL FIXSTOR_OFFSHORE(ILC,IEG,IEL,0.0,NEF,1.0D0,'INI','VARY')  !INITIALIZE FIXEND FILE NFL2 FOR VARY     LOAD
	!ENDDO
      
      GOTO 2000
      
	DO ILC = 1,LCS
	CALL FIXSTOR(ILC,IEG,IEL,0.0,NEF,1.0D0,'INI','VARY')  !INITIALIZE FIXEND FILE NFL2 FOR VARY     LOAD
	CALL FIXSTOR(ILC,IEG,IEL,0.0,NEF,1.0D0,'INI','CONT')  !INITIALIZE FIXEND FILE NFL2 FOR CONSTANT LOAD
      !CALL FIXSTOR_OFFSHORE(ILC,IEG,IEL,0.0,NEF,1.0D0,'INI','VARY')  !INITIALIZE FIXEND FILE NFL2 FOR VARY     LOAD
	!CALL FIXSTOR_OFFSHORE(ILC,IEG,IEL,0.0,NEF,1.0D0,'INI','CONT')  !INITIALIZE FIXEND FILE NFL2 FOR CONSTANT LOAD
	ENDDO
	
2000  CONTINUE
      
      CALL INTFILL('OGDM',NA,1,60,0)
	DEALLOCATE(AF1,AF2)

	CALL PRNGAUS(ITYPE,ISTYP,NPT,ICONDT(KGAS))  !ELEMENT GAUSS POINT PRINTING

2500	CONTINUE


	DEALLOCATE(LEST)

	RETURN
	END



C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE INIGRP
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*1 NAMEI(4)
      DIMENSION   INAME(4)

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON /CONSTINT/ MTOTI(10),NCONI(5000),ICONDT(1)
      COMMON /CONSTREL/ MTOTR(10),NCONR(5000),RCONDT(1)

      COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM
	COMMON /SPBC/ NSS,NLSS
      COMMON /MGLENK/ NGLELM,NGLSET,LNKLEN,LNKWRK,LNKFRE,LEKNOD(5000) 

      COMMON /ELEM/ NAME(2),ITYPE,ISTYP,NLOPT,MTMOD,NSINC,ITOLEY,
     1              NELE,NMPS,NGPS,NMP,NGP,NNM,NEX,NCO,NNF,NWG,NEFC,
     2              NPT,NWA,NWS,KEG,MEL,NNO,NEF,NELTOT,NMV,MTYP,ISECT
      COMMON /GAUS/ GLOC(10,10),GWT(10,10),NGR,NGS,NGT
	COMMON /GiDEle/ LGID

	COMMON /BF_SMOTH/ NP_SMH

      COMMON A(9000000),IA(9000000)

      COMMON /LOCO/ LOP,LOS,LSS,LSS2,LSS3,LHG,LHGN

	DIMENSION NPM(10),NPI(10)
      ALLOCATABLE LEST(:)


C	-------------------------------------------
C	PROBLEM LEVEL
C	-------------------------------------------
	NOUT1 = NGLELM  !LINK
	NOUT2 = 8*2
	CALL DEFNREL('OLNK',KLNK,NOUT2,NOUT1)        
	CALL RELZERO('OLNK')

	NOUT1 = NSN		!GLOBAL SUPPORT
	NOUT2 = 10*2
	CALL DEFNREL('OGSP',KSUPG,NOUT2,NOUT1)        
	CALL RELZERO('OGSP')

	NOUT1 = NSN		!LOCAL SUPPORT
	NOUT2 = 10*2
	CALL DEFNREL('OLSP',KSUPL,NOUT2,NOUT1)        
	CALL RELZERO('OLSP')

	NOUT1 = NSN	!NODAL DISPLACEMENT
	NOUT2 = 10*2     
	CALL DEFNREL('ONDS',KDISP,NOUT2,NOUT1)  
	CALL RELZERO('ONDS')

	NOUT1 = NSS	!SPRING SUPPORT
	NOUT2 = 7*2
	CALL DEFNREL('OGSS',KGSS,NOUT2,NOUT1)        
	CALL RELZERO('OGSS')

	NOUT1 = NLSS	!LOCAL SPRING SUPPORT
	NOUT2 = 7*2
	CALL DEFNREL('OLSS',KLSS,NOUT2,NOUT1)        
	CALL RELZERO('OLSS')
C	-------------------------------------------


C	------------------------
C	ELEMENT GROUP LEVEL
C	------------------------

C	CALLING NEG
	CALL INTFILL('%NUB',NEG,1,5 ,0)
	CALL INTFILL('%NUB',LEL,1,10,0)  !LEL  ELEMENT GROUP POINTER

	ALLOCATE(LEST(2*NEG))
	DO II = 1,2*NEG
	LEST(II) = IA(LEL+II-1)
	ENDDO


C	ADDRESS FOR GROUP
	CALL DEFNINT('OGRP',NGRP,30,NEG)  !GROUP DATA   
	CALL DEFNINT('OGRF',NGRF,20,NEG)  !GROUP FILE


C	TOTAL GID ELEMENT 
	NGIDM = 0
	DO IEG = 1,NEG
	NELEMI = 10 + IEG
      NELEMA = 30 + IEG
      REWIND NELEMI
      REWIND NELEMA
C      READ (NELEMI) (IA(NLNU),NLNU=LNU,LNU + LEST(IEG)-1)
C      READ (NELEMA) ( A(NLNU),NLNU=LMP,LMP + LEST(IEG+NEG)-1)
      READ (NELEMI) IA(LNU:LNU + LEST(IEG)-1)
      READ (NELEMA)  A(LMP:LMP + LEST(IEG+NEG)-1)
      CALL MOVLEV (2)
	DO IELE = 1,NELE
	IGM = IA(LGID+IELE-1)
	IF(IGM.GT.NGIDM) NGIDM = IGM
	ENDDO
C	NGIDM = NGIDM + NELE
	ENDDO

C	GID ELEMENT MAPPING ARRAY
	CALL DEFNINT('OGDM',KGDM,3,NGIDM) 
	CALL INTZERO('OGDM')

C	FOR FRAME ELEMENT POINTER DATA
	CALL DEFNINT('FRMP',KFRMP,5,NEG) 
	CALL INTZERO('FRMP')

C	----------------------------------------
C	LOOP OVER ELEMENT GROUP 
C	----------------------------------------	
	DO 2500 IEG = 1,NEG
	NELEMI = 10 + IEG
      NELEMA = 30 + IEG
      REWIND NELEMI
      REWIND NELEMA
C      READ (NELEMI) (IA(NLNU),NLNU=LNU,LNU + LEST(IEG)-1)
C      READ (NELEMA) ( A(NLNU),NLNU=LMP,LMP + LEST(IEG+NEG)-1)
      READ (NELEMI) IA(LNU:LNU + LEST(IEG)-1)
      READ (NELEMA)  A(LMP:LMP + LEST(IEG+NEG)-1)
      CALL MOVLEV (2)
	

	SELECTCASE(ITYPE)

	CASE(2)
	NOUT = 3*1
	LENGTH = 3
	MGAS = 1

      CASE(5)
	!MST  = 12  !MAXIMUM STRESS POINT FOR FRAME SECTION
	!MFC  = 7   !FORCE COMPONENT FOR ONE STATION POINT
      MST  = 21  !MAXIMUM STRESS POINT FOR FRAME SECTION BY BJ
	MFC  = 21   !FORCE COMPONENT FOR ONE STATION POINT BY BJ
	NOUT = (2+NP_SMH)*(MFC+MST)  
	CALL INTFILL('FRMP',NP_SMH,1,IEG,1)
	CALL INTFILL('FRMP',MST   ,2,IEG,1)
	CALL INTFILL('FRMP',MFC   ,3,IEG,1)
	LENGTH = MFC+MST

	INAME(1:4) = [5,0,1,IEG] !XSEF
	CALL ICONC(INAME,NAMEI)
	CALL MINTFIL(NAMEI,MGAS,1,3,0) !SEE GENFIBER.FOR

	CASE(6)
	NOUT = (NPT+NNM)*5
	LENGTH = 5
	MGAS = NPT

	CASE(8)
	NOUT = (NPT+NNM)*5
	LENGTH = 5
	MGAS = NPT

	CASE(9)
	NOUT = (NPT+NNM)*8
	LENGTH = 8
	IF(MTMOD.EQ.1) THEN
	NOUT = (NPT+NNM)*(8+6*3)  !8 RESULTANT 6 TOP&MID&BOTTOM STRESS
	LENGTH = (8+6*3)
	ENDIF
	IF(MTMOD.EQ.4) THEN
	NOUT = (NPT+NNM)*(8+3*2)  !8 RESULTANT 3 TOP&BOTTOM STRESS
	LENGTH = 8+3*2
	ENDIF
	MGAS = NPT

	CASE(10)
	IF(ISTYP.EQ.4) THEN ! FOR SOLID-SHELL
	  NOUT = (NPT+NNM)*10
	  LENGTH = 10
	  MGAS = NPT	
	ELSE
	  NOUT = (NPT+NNM)*7
	  LENGTH = 7
	  MGAS = NPT
	ENDIF    
	
	CASE(11)
	NOUT = (NPT+NNM)*7
	LENGTH = 7
	MGAS = NPT

	CASE(13)
	NOUT = NPT*2
	LENGTH = 2
	MGAS = NPT

	CASE(14)
	NOUT = NPT*3
	LENGTH = 3
	MGAS = NPT

	CASE(15)
	NOUT = NPT*2
	LENGTH = 2
	MGAS = NPT

	CASE(16)
	NOUT = NPT*3
	LENGTH = 3
	MGAS = NPT

	CASE(20)
	NOUT = NPT*2
	LENGTH = 2
	MGAS = NPT

	CASE(21)
	NOUT = NPT*3
	LENGTH = 3
	MGAS = NPT

	CASE(17)	!TENDON
	NOUT = NPT*3
	LENGTH = 3
	MGAS = NPT

	ENDSELECT

	N1 = NOUT*2
	N2 = NEF         !************
	N3 = NEF         !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
      N4 = NNM         !FOR STORING THE CONNECTIVITY

      
C	OPEN FILE FOR STORE GROUP DATA
	CALL INTFILL('NOUT',NFIL,1,3,0)   !ELEMENT GROUP STORAGE FILE
	NFLL = 10
	NFL1 = 1 + NFLL*(IEG-1) + NFIL
	NFL2 = 2 + NFLL*(IEG-1) + NFIL
	NFL3 = 3 + NFLL*(IEG-1) + NFIL    !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	NFL4 = 4 + NFLL*(IEG-1) + NFIL    !FOR STORING THE CONNECTIVITY
      NFL5 = 5 + NFLL*(IEG-1) + NFIL    !NEW INDICATOR FOR NEW ARRAY OF SAVING LOCAL STRESS OF SOLID-SHELL(P) BY BJ
      NFL6 = 6 + NFLL*(IEG-1) + NFIL    !OFFSHORE LOAD CASE BY TOEY
      NFL7 = 7 + NFLL*(IEG-1) + NFIL    !OFFSHORE REACTION BY TOEY
      NFL8 = 8 + NFLL*(IEG-1) + NFIL    !OFFSHORE VECTOR BY TOEY
      NFL9 = 9 + NFLL*(IEG-1) + NFIL    !OFFSHORE FORCE BY TOEY\
      NFL10 = 10 + NFLL*(IEG-1) + NFIL    !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
      
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,1) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,1) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,1) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,1) !
	CALL INTFILL('OGRP',MGAS ,5 ,IEG,1) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,1) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,1) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,1) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,1) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,1) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,1) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,1) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,1) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,1) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,1) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,1) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,1) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,1) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,1) !
	CALL INTFILL('OGRF',N2   ,2 ,IEG,1) !
	CALL INTFILL('OGRF',N3   ,3 ,IEG,1) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL INTFILL('OGRF',N4   ,4 ,IEG,1) !FOR STORING THE CONNECTIVITY
	CALL INTFILL('OGRF',NFL1 ,11,IEG,1) !
	CALL INTFILL('OGRF',NFL2 ,12,IEG,1) !FOR FIXEND FORCES
	CALL INTFILL('OGRF',NFL3 ,13,IEG,1) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
	CALL INTFILL('OGRF',NFL4 ,14,IEG,1) !FOR STORING THE CONNECTIVITY
      CALL INTFILL('OGRF',NFL5 ,15,IEG,1) !NEW INDICATOR FOR NEW ARRAY OF SAVING LOCAL STRESS OF SOLID-SHELL(P) BY BJ
      CALL INTFILL('OGRF',NFL6 ,16,IEG,1) !OFFSHORE LOAD CASE BY TOEY
      CALL INTFILL('OGRF',NFL7 ,17,IEG,1) !OFFSHORE REACTION BY TOEY
      CALL INTFILL('OGRF',NFL8 ,18,IEG,1) !OFFSHORE VECTOR BY TOEY
      CALL INTFILL('OGRF',NFL9 ,19,IEG,1) !OFFSHORE FORCE BY TOEY
      CALL INTFILL('OGRF',NFL10 ,20,IEG,1) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM OFFSHORE
      
2500	CONTINUE


	DEALLOCATE(LEST)

	RETURN
	END



C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE GIDMAP
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------
	CHARACTER*200 NAME
	CHARACTER*200 LHDGRP

	COMMON /GHEADER/ LHDGRP(500)

C	CALL GID ELEMENT NUMBER  NGIDM
	CALL LOCATN('OGDM',KGDM,NN,NGIDM,1) 

	CALL INTFILL('%IOL',ITI,1,1,0)  !DATIN.DAT FILE

	CALL DEFNINT('#GMP',NGMP,1,5)		!TOTAL GID GROUP NUMBER   
	CALL DEFNINT('@GMP',NGMP,1,NGIDM)   !GROUP NUMBER OF GID ELEMENT  

      CALL INTZERO('#GMP')
      CALL INTZERO('@GMP')


	READ(ITI,*)
	READ(ITI,*) NEGRP,NEGEL

	CALL INTFILL('#GMP',NEGRP,1,1,1)  !
	CALL INTFILL('#GMP',NEGEL,1,2,1)  !

	DO IGRP = 1,NEGRP
	READ(ITI,'(A200)') NAME
	LHDGRP(IGRP) = NAME
	ENDDO


	DO II = 1,NEGEL
	READ(ITI,*) IGM,IEGRP
C      CALL FAST_MATERIAL_DATA(II,IGM,IEGRP,NEGEL) !SONGSAK DELETE HERE ... OCT2019 [REMOVE COMMON /STOREN/, /STOREN_MATERIAL/ AND USE CONSISTENT STORAGE]
	CALL INTFILL('@GMP',IEGRP,1,IGM,1)  !
	ENDDO
	
	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================	

	SUBROUTINE WRITCON(IGM,IEL,LM,NNM,NEF,NFL) 
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      DIMENSION LM(NEF,1)
      
      WRITE(NFL,REC=IGM,ERR=10) NNM,LM(1:NNM,IEL)
10    CONTINUE
      	
	RETURN
	END
C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================

	SUBROUTINE READCON(IGM,LM,NFL) 
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      DIMENSION LM(1)
      
      READ(NFL,REC=IGM,ERR=10) NNM,LM(1:NNM)
10    CONTINUE
      	
	RETURN
      END
C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================

	SUBROUTINE READCON_T(IGM,LM,NFL,NNM) 
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      DIMENSION LM(1)
      
      READ(NFL,REC=IGM,ERR=10) NNM,LM(1:NNM)
10    CONTINUE
      	
	RETURN
	END
C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE ELMCONNOD(IEL,IEG) 
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      DIMENSION LM(100),ECORD(3,100)
C     --------------------------------------------
C     INPUT ... IEL and IEG
C     OUTPUT:                       
C         LM(NNM) = ELEM. CONNECTIVITY ... SIZE = NNM NUMBER OF NODES IN ONE ELEMENT
C    ECORD(3,NNM) = ELEM. COORRDINATES ... SIZE = 3 x NNM 
      
C     REMARK:
C     -BEFORE CALLING THIS SUB., THE PARENT SUB. SHOULD PREPARE ENOUGH SPACE OF LM&ECORD 
C      
C     -THIS SUB. WILL WORK AFTER CALLING SUB.INIOUT1 IN SUB.INPUT1
C     --------------------------------------------
      
C	CALLING TOTAL NUMBER OF GID ELEMENT ... NGIDM
	CALL LOCATN('OGDM',KGDM,NDUMY,NGIDM,1) 

C     CALLING NSC ... NUMBER OF STRUCTURAL DIMENSIONS NSC ... 1D, 2D, 3D
	CALL INTFILL('%NUB',NSC ,1,4 ,0)      
      
C     --------------------------------------------
      IFOUND = 0
      DO 100 IGM = 1,NGIDM
          
C	CALL GID ELEMENT MAPPING DATA
          CALL INTFILL('OGDM',IEGM,1,IGM,0)
          CALL INTFILL('OGDM',IELM,2,IGM,0)
          
          IF(IEG.EQ.IEGM.AND.IEL.EQ.IELM) THEN
              IFOUND = 1
              EXIT
          ENDIF
          
100   CONTINUE   
C     --------------------------------------------
C     EXTRACT ELEMENT DATA 
      IF(IFOUND.EQ.1) THEN
          
	    CALL INTFILL('OGRP',NNM ,7 ,IEG,0) !CALL NUMBER OF NODE IN ELEMENT ... NNM
	    CALL INTFILL('OGRF',NFL4,14,IEG,0) !CALL FILE NUMBER STORED THE CONNECTIVITY
          
          CALL READCON(IGM,LM,NFL4) !CALLING ELEM. CONNECTIVITY FROM RECORDED FILE
          
          DO J = 1,NNM
              INOD = LM(J)
	        DO I = 1,NSC
                  CALL RELFILL('@XYZ',ECORD(I,J),I,INOD,0)  !CALL HERE NODAL COORDINATE
              ENDDO
          ENDDO
          
      ELSEIF(IFOUND.EQ.0) THEN
          
          WRITE(*,*) 'WARNING ELEMENT NUMBER NOT FOUND IN SUB. ELMCONNOD'
          STOP
          
      ENDIF
      
C     --------------------------------------------
      
	RETURN
	END
C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================

	SUBROUTINE BACKLCS(LCS,OPER)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*4 OPER

C     MAKE INDEX DATA
	CALL INIOPER(0,0,0.0D0,'INDX','OLDF')
	
	CALL INTFILL('NOUT',NFIL,1,1,0)  !LOAD CASE OUTPUT FILE
	FACT = 1.0D0
	CALL INIOPER(NFIL,LCS,FACT,OPER,'OLDF')

	
	RETURN
	END
C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================

	SUBROUTINE OUTLENG
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------
      DIMENSION DUMMY(1)
C     ----------------------------------------------------------------

	CALL DEFNINT('NPLN',NPRN,1,30)    !LENGTH OF PRINTING (SEE ALSO INIOPER)
	CALL INTZERO('NPLN')
	
	
	CALL DEFNINT('FIDX',NIDX,1,5000)  !FILE INDEX FLAG (SIZE SHOULD BE EQUAL TO MAXIMUM FILE NUMBER)
	CALL INTZERO('FIDX')
	
	CALL INTFILL('NPLN',NUMLIN,1,10,0)  
	CALL INTFILL('NPLN',NUMDAT,1,20,0) 
	IF(NUMLIN.GT.0) GOTO 50


	IREAD =  1
	IND   = -1
	LP    = -1
	FACT  = 0.0D0
	
	NUMLIN = 1 !FIRST LINE STORE FILE CONFIG  (LCONF)
	NUMDAT = 1 !NUMBER OF DATA STORAGE
	NL1  = NUMLIN
	NLD1 = NUMDAT
	CALL GRPOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,DUMMY)
	NL2  = NUMLIN
	NLD2 = NUMDAT
	CALL LIKOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,DUMMY)
	NL3  = NUMLIN
	NLD3 = NUMDAT
	CALL RCTOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,DUMMY)
	NL4  = NUMLIN
	NLD4 = NUMDAT
	CALL DISOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,DUMMY)
	NL5  = NUMLIN
	NLD5 = NUMDAT
	CALL SPGOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,DUMMY)
	NL6  = NUMLIN
	NLD6 = NUMDAT
	CALL SPLOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,DUMMY)

      MXL1 = 0
      MXL2 = 0
      MXL3 = 0
      MXL4 = 0
      MXL5 = 0
      MXL6 = 0
      MXLN = 0
      IF(NL2.GT.NL1) MXL1 = INT((NLD2-NLD1)/(NL2-NL1) + 1)
      IF(MXL1.GT.MXLN) MXLN = MXL1
      
      IF(NL3.GT.NL2) MXL2 = INT((NLD3-NLD2)/(NL3-NL2) + 1)
      IF(MXL2.GT.MXLN) MXLN = MXL2
      
      IF(NL4.GT.NL3) MXL3 = INT((NLD4-NLD3)/(NL4-NL3) + 1)
      IF(MXL3.GT.MXLN) MXLN = MXL2
      
      IF(NL5.GT.NL4) MXL4 = INT((NLD5-NLD4)/(NL5-NL4) + 1)
      IF(MXL4.GT.MXLN) MXLN = MXL4
      
      IF(NL6.GT.NL5) MXL5 = INT((NLD6-NLD5)/(NL6-NL5) + 1)
      IF(MXL5.GT.MXLN) MXLN = MXL5
      
      IF(NUMLIN.GT.NL6) MXL6 = INT((NUMDAT-NLD6)/(NUMLIN-NL6) + 1)
      IF(MXL6.GT.MXLN) MXLN = MXL6


	CALL INTFILL('NPLN',NL1   ,1,1 ,1)  
	CALL INTFILL('NPLN',NL2   ,1,2 ,1)  
	CALL INTFILL('NPLN',NL3   ,1,3 ,1)  
	CALL INTFILL('NPLN',NL4   ,1,4 ,1)  
	CALL INTFILL('NPLN',NL5   ,1,5 ,1)  
	CALL INTFILL('NPLN',NL6   ,1,6 ,1)  
	CALL INTFILL('NPLN',NUMLIN,1,10,1)  

	CALL INTFILL('NPLN',NLD1  ,1,11,1)  
	CALL INTFILL('NPLN',NLD2  ,1,12,1)  
	CALL INTFILL('NPLN',NLD3  ,1,13,1)  
	CALL INTFILL('NPLN',NLD4  ,1,14,1)  
	CALL INTFILL('NPLN',NLD5  ,1,15,1)  
	CALL INTFILL('NPLN',NLD6  ,1,16,1)  
	CALL INTFILL('NPLN',NUMDAT,1,20,1) 

C     Maximum storage size per line of direct access file for output
	CALL INTFILL('NPLN',MXL1   ,1,21 ,1)  
	CALL INTFILL('NPLN',MXL2   ,1,22 ,1)  
	CALL INTFILL('NPLN',MXL3   ,1,23 ,1)  
	CALL INTFILL('NPLN',MXL4   ,1,24 ,1)  
	CALL INTFILL('NPLN',MXL5   ,1,25 ,1)  
	CALL INTFILL('NPLN',MXL6   ,1,26 ,1)  
	CALL INTFILL('NPLN',MXLN   ,1,30 ,1)  
	
50	RETURN
	
	END
C	=======================================================================
C	=== NEW OUTPUT ========================== SONGSAK FEB2008 =============
C	=======================================================================
	SUBROUTINE INIOPER(LP,NSTEP,FACT,OPER,FILE)   
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*4 OPER,FILE
C     ----------------------------------------------------------------
      ALLOCATABLE AOUT(:)
C     ----------------------------------------------------------------

C	OPEN FILE
	INF = -1
	IF(FILE.EQ.'NEWF') THEN
	CALL INTFILL('NPLN',NUMDAT,1,20,0) 
	CALL INTFILL('NPLN',MXLN  ,1,30,0) !Max storge for one line
	LRECL = INT(2*MXLN)
	INF = 0						!OPEN DIRECT ACCESS FILE
	CALL DIROPEN(LP,LRECL)
	ENDIF
	IF(FILE.EQ.'NEWS') THEN
	INF = 1						!OPEN SEQUENTIAL FILE
	OPEN (LP,FORM='UNFORMATTED',STATUS='SCRATCH')
	ENDIF
      
C	PERFORM OPERATION
	IND = -1
	IF(OPER.EQ.'CALL') IND = 0  !CALL DATA
	IF(OPER.EQ.'REPC') IND = 1  !WRITE TO FILE
	IF(OPER.EQ.'COMB') IND = 2  !ACUMULATE DATA TO FILE
	IF(OPER.EQ.'CLER') IND = 3  !CLEAR DATA   
	IF(OPER.EQ.'CLEF') IND = 4  !CLEAR FILE DATA
	IF(OPER.EQ.'ACUM') IND = 5  !ACUMULATE DATA
	IF(OPER.EQ.'SORT') IND = 6  !SORT DATA TO FILE
	IF(OPER.EQ.'REPL') IND = 7  !REPLACE DATA TO FILE WITH LANE POINT LOAD
	IF(OPER.EQ.'SQRT') IND = 8  !READ DATA FROM FILE THEN SQRT ANd BACKUP TO FILE
	IF(OPER.EQ.'COML') IND = 9  !ACUMULATE DATA TO FILE FOR LANE LOAD (POSITIE & NEGATIVE)
	IF(OPER.EQ.'INDX') IND = 10 !MAKE NODE INDEX AND STORE IN MEMORY (RAM)
	IF(OPER.EQ.'ISOT') IND = 11 !MAKE SORT INDEX TO FILE (1.0D0 = SORT MAX -- -1.0D0 = SORT MIN)
	IF(OPER.EQ.'MULT') IND = 12 !MULTIPLY DATA AND STORE TO RAM (CALL DATA FROM FILE)
	IF(IND.EQ.-1) RETURN


	CALL INTFILL('NPLN',NL1   ,1,1 ,0)  
	CALL INTFILL('NPLN',NL2   ,1,2 ,0)  
	CALL INTFILL('NPLN',NL3   ,1,3 ,0)  
	CALL INTFILL('NPLN',NL4   ,1,4 ,0)  
	CALL INTFILL('NPLN',NL5   ,1,5 ,0)  
	CALL INTFILL('NPLN',NL6   ,1,6 ,0)  
	CALL INTFILL('NPLN',NUMLIN,1,10,0)
	
	CALL INTFILL('NPLN',NLD1  ,1,11,0)  
	CALL INTFILL('NPLN',NLD2  ,1,12,0)  
	CALL INTFILL('NPLN',NLD3  ,1,13,0)  
	CALL INTFILL('NPLN',NLD4  ,1,14,0)  
	CALL INTFILL('NPLN',NLD5  ,1,15,0)  
	CALL INTFILL('NPLN',NLD6  ,1,16,0)  
	CALL INTFILL('NPLN',NUMDAT,1,20,0)
	 
	CALL INTFILL('NPLN',MXLN  ,1,30,0) !Max storge for one line
      
      IF(NSTEP.GT.0) THEN 
	    NL1 = NL1+NUMLIN*(NSTEP-1)
	    NL2 = NL2+NUMLIN*(NSTEP-1)
	    NL3 = NL3+NUMLIN*(NSTEP-1)
	    NL4 = NL4+NUMLIN*(NSTEP-1)
	    NL5 = NL5+NUMLIN*(NSTEP-1)
	    NL6 = NL6+NUMLIN*(NSTEP-1)
	ENDIF
      
      ALLOCATE(AOUT(MXLN))
      AOUT(1:MXLN) = 0.0D0
                	
	IREAD = 0
      IF(OPER.EQ.'ISOT') IREAD = 2  !NO READ AOUT
      IF(OPER.EQ.'INDX') IREAD = 2  !NO READ AOUT -- Just call node index
      IF(OPER.EQ.'CALL') IREAD = 3  !NO WRITE AOUT
	IF(OPER.EQ.'CLER') IREAD = 3  !NO WRITE AOUT  
	IF(OPER.EQ.'ACUM') IREAD = 3  !NO WRITE AOUT
	IF(OPER.EQ.'MULT') IREAD = 3  !NO WRITE AOUT
      
	CALL GRPOPER(LP,IND,FACT,IREAD,NL1,NLD1,AOUT(1))
	CALL LIKOPER(LP,IND,FACT,IREAD,NL2,NLD2,AOUT(1))
	CALL RCTOPER(LP,IND,FACT,IREAD,NL3,NLD3,AOUT(1))
	CALL DISOPER(LP,IND,FACT,IREAD,NL4,NLD4,AOUT(1))
	CALL SPGOPER(LP,IND,FACT,IREAD,NL5,NLD5,AOUT(1))
	CALL SPLOPER(LP,IND,FACT,IREAD,NL6,NLD6,AOUT(1))
	
	
	IF(OPER.EQ.'REPC') LCONF = 1 !WRITE TO FILE
	IF(OPER.EQ.'COMB') LCONF = 1 !ACUMULATE DATA TO FILE
	IF(OPER.EQ.'CLEF') LCONF = 0 !CLEAR FILE DATA
	IF(OPER.EQ.'SORT') LCONF = 1 !SORT DATA TO FILE
	IF(OPER.EQ.'REPL') LCONF = 1 !REPLACE DATA TO FILE WITH LANE POINT LOAD
	IF(OPER.EQ.'SQRT') LCONF = 1 !READ DATA FROM FILE THEN SQRT ANd BACKUP TO FILE
	IF(OPER.EQ.'COML') LCONF = 1 !ACUMULATE DATA TO FILE FOR LANE LOAD (POSITIE & NEGATIVE)
	IF(OPER.EQ.'ISOT') LCONF = 0 !MAKE SORT INDEX TO FILE (1.0D0 = SORT MAX -- -1.0D0 = SORT MIN)
      CALL INTFILL('FIDX',LCONF,1,LP,1) 
      
80    CONTINUE

      DEALLOCATE(AOUT)
      


      RETURN
      END


C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE GRPOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,AOUT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------
	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:)
      ALLOCATABLE AF2(:) ! FOR SOLID-SHELL(P) BY BJ
	DIMENSION AOUT(1)
C     ---------------------------------------------------

      CALL INTFILL('FIDX',LCONF,1,LP,0) 
      
C	CALLING NEG
	CALL INTFILL('%NUB',NEG,1,5 ,0)

C	---------------------
      N1_MAX = 0
      NL_INT = NUMLIN
C	---------------------
      
	KELG = 0

	DO 2000 IEG = 1,NEG


C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !
      CALL INTFILL('OGRF',NFL5 ,15,IEG,0) !!NEW INDICATOR FOR NEW ARRAY OF SAVING LOCAL STRESS OF SOLID-SHELL(P) BY BJ

C	---------------------
      IF(N1.GT.N1_MAX) N1_MAX = N1
C	---------------------

	ALLOCATE(AF1(N1))
      
      ALLOCATE(AF2(N1)) ! FOR SOLID-SHELL(P) BY BJ
      

	DO 1000 IEL=1,NELE
	  
      IF(IREAD.NE.1) READ(NFL1,REC=IEL) AF1(1:N1)  
      IF(IREAD.NE.1) READ(NFL5,REC=IEL) AF2(1:N1)  
      
	KELG = KELG + 1
C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	GOTO 1000
      ENDIF
C	---------------------

	NRC = NUMLIN + KELG 
      
      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:N1) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=10) AOUT(1:N1) !Read output data
          GOTO 20
10        AOUT(1:N1) = 0.0D0
20        CONTINUE    
      ENDIF

	SELECTCASE(IND)

	CASE(0)
      AF1(1:N1) = AOUT(1:N1)*FACT

	CASE(1)
	AOUT(1:N1) = AF1(1:N1)*FACT

	CASE(2)
	AOUT(1:N1) = AOUT(1:N1) + AF1(1:N1)*FACT

	CASE(3)
	AF1(1:N1) = 0.0D0
      AF2(1:N1) = 0.0D0  ! FOR SOLID-SHELL(P) BY BJ

	CASE(4)
	AOUT(1:N1) = 0.0D0

	CASE(5)
	AF1(1:N1) = AF1(1:N1) + AOUT(1:N1)*FACT

	CASE(6)
	DO I1 = 1,N1
	    IF(I1.LE.N1/2) THEN
	      IF( FACT*AF1(I1).GE.AOUT(I1) ) AOUT(I1) = FACT*AF1(I1)
	    ENDIF
	    IF(I1.GT.N1/2) THEN
	      IF( FACT*AF1(I1).LE.AOUT(I1) ) AOUT(I1) = FACT*AF1(I1)
	    ENDIF
	    IF(LCONF.EQ.0) AOUT(I1) = FACT*AF1(I1)	
	ENDDO
	

	CASE(7) !REPLACE SPECIFIC DATA TO FILE WITH LANE POINT LOAD
	IF(ITYPE.EQ.5) THEN !FOR FRAME ELEMENT
	    DO I1 = 1,N1/LENGTH
	        NUM =  (2+LENGTH*(I1-1))
	        AOUT(NUM) = FACT*AF1(NUM) !HERE WE REPLACE FRAME SHEAR-S DUE TO SHEAR (LANE) POINT LOAD
	        NUM =  (3+LENGTH*(I1-1))
	        AOUT(NUM) = FACT*AF1(NUM) !HERE WE REPLACE FRAME SHEAR-T DUE TO SHEAR (LANE) POINT LOAD	
	    ENDDO
	ENDIF
	
	
	CASE(8)
	DO I = 1,N1
	AOUT(I) = SQRT( ABS(AOUT(I)) )*FACT
	ENDDO
	
	
	CASE(9)
	DO I1 = 1,N1
	    IF(I1.LE.N1/2) THEN
	      IF( AF1(I1).GE.0.0D0 ) AOUT(I1) = AOUT(I1) + AF1(I1)*FACT
	    ENDIF
	    IF(I1.GT.N1/2) THEN
	      IF( AF1(I1).LE.0.0D0 ) AOUT(I1) = AOUT(I1) + AF1(I1)*FACT
	    ENDIF	
	ENDDO
	
	CASE(10)
C     NO INDEX FOR ELEMENT GROUP
      CONTINUE
     
     	CASE(11)
     	    N12 = N1/2
     	    AOUT(1    :N12) = 1.0D0
     	    AOUT(1+N12:N1 ) =-1.0D0
     	    
	CASE(12)
	AF1(1:N1) = AF1(1:N1)*AOUT(1:N1)
	
	ENDSELECT

C	---------------------
	SELECTCASE(IND)
	    CASE(0,3,5)
              IF(IREAD.NE.1) WRITE(NFL1,REC=IEL) AF1(1:N1)  
              IF(IREAD.NE.1) WRITE(NFL5,REC=IEL) AF2(1:N1)  
	    CASE(1,2,4,6,7,8,9)
	        CONTINUE
      ENDSELECT
      
      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:N1) !Backup output data
      
1000	CONTINUE

      DEALLOCATE(AF1,AF2) !AF2 FOR SOLID-SHELL(P) BY BJ
      
2000	CONTINUE

C	---------------------
	IF(IREAD.EQ.1) NUMDAT = N1_MAX*(NUMLIN-NL_INT)
C	---------------------

	RETURN

      END
C	=====================================================================
C	=====================================================================
C	=====================================================================


	SUBROUTINE LIKOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,AOUT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	-------------------------------------------------------------------
	ALLOCATABLE EDAT(:)
	DIMENSION AOUT(1)

      CALL INTFILL('FIDX',LCONF,1,LP,0) 
	
	CALL LOCATN('OLNK',KLNK,NOUT2,NGLELM,2)
	IF(NGLELM.EQ.0) RETURN


	ALLOCATE(EDAT(NOUT2))


	DO 1000 IELE = 1,NGLELM


C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	NUMDAT = NUMDAT + NOUT2
	GOTO 1000
	ENDIF
C	---------------------

	NRC = NUMLIN + IELE
      
      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:NOUT2) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=10) AOUT(1:NOUT2) !Read output data
          GOTO 20
10        AOUT(1:NOUT2) = 0.0D0
20        CONTINUE    
      ENDIF
      
      
	SELECTCASE(IND)

	CASE(0)
	
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	FND2 = EDAT(2)
	DO I = 1,NOUT2
	VALV = EDAT(I)*FACT
	IF(I.EQ.1) VALV = FND1 
	IF(I.EQ.2) VALV = FND2
	CALL RELFILL('OLNK',VALV,I,IELE,1)
	ENDDO

	CASE(1)
	DO I = 1,NOUT2
	CALL RELFILL('OLNK',VALV,I,IELE,0)
	IF(I.EQ.1) FND1 = VALV
	IF(I.EQ.2) FND2 = VALV
	EDAT(I) = VALV*FACT
	ENDDO
	EDAT(1) = FND1
	EDAT(2) = FND2
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(2)
	
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OLNK',VALV,I,IELE,0)
	IF(I.EQ.1) FND1 = VALV
	IF(I.EQ.2) FND2 = VALV
	EDAT(I) = EDAT(I)+VALV*FACT
	ENDDO
	EDAT(1) = FND1
	EDAT(2) = FND2
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(3)
	DO I = 1,NOUT2
	VALV = 0.0
	CALL RELFILL('OLNK',VALV,I,IELE,1)
	ENDDO

	CASE(4)
	EDAT(1:NOUT2) = 0.0D0
	CALL RELFILL('OLNK',EDAT(1),1,IELE,0)
	CALL RELFILL('OLNK',EDAT(2),2,IELE,0)
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(5)
	
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	FND2 = EDAT(2)
	DO I = 1,NOUT2
	CALL RELFILL('OLNK',VALV,I,IELE,0)
	IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	IF(FND2.EQ.0.0D0.AND.I.EQ.2) FND2 = VALV 
	VALV = VALV + EDAT(I)*FACT
	IF(I.EQ.1) VALV = FND1 
	IF(I.EQ.2) VALV = FND2
	CALL RELFILL('OLNK',VALV,I,IELE,1)
	ENDDO

	CASE(6)
	
	EDAT(1:NOUT2) = AOUT(1:NOUT2)

	FND1 = EDAT(1)
	FND2 = EDAT(2)
	DO I = 1,NOUT2
	    CALL RELFILL('OLNK',VALV,I,IELE,0)
	        IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV
	        IF(FND2.EQ.0.0D0.AND.I.EQ.2) FND2 = VALV
	        IF(I.LE.NOUT2/2) THEN
	          IF( FACT*VALV.GE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(I.GT.NOUT2/2) THEN
	          IF( FACT*VALV.LE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(LCONF.EQ.0) EDAT(I) = VALV*FACT	
	ENDDO
	EDAT(1) = FND1
	EDAT(2) = FND2
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(7)
C     NOTHING SPACIAL FOR LANE POINT LOad
      CONTINUE
      

	CASE(8)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	EDAT(I) = SQRT( ABS(EDAT(I)) )*FACT
	ENDDO
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)


	CASE(9)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	FND2 = EDAT(2)
	DO I = 1,NOUT2
	    CALL RELFILL('OLNK',VALV,I,IELE,0)
	    IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	    IF(FND2.EQ.0.0D0.AND.I.EQ.2) FND2 = VALV 
	    IF(I.LE.NOUT2/2) THEN
	      IF( VALV.GE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF
	    IF(I.GT.NOUT2/2) THEN
	      IF( VALV.LE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF
	ENDDO
	EDAT(1) = FND1
	EDAT(2) = FND2
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)
	
	CASE(10)
C     INDEX FOR LINK ELEMENT -- SKIP...ALWAY DO AT THE END OF LOOP
	     
     	CASE(11)
     	    NOUT22 = NOUT2/2
     	    AOUT(1       :NOUT22) = 1.0D0
     	    AOUT(1+NOUT22:NOUT2 ) =-1.0D0

	CASE(12)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	FND2 = EDAT(2)
	DO I = 1,NOUT2
	CALL RELFILL('OLNK',VALV,I,IELE,0)
	IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	IF(FND2.EQ.0.0D0.AND.I.EQ.2) FND2 = VALV 
	VALV = VALV*EDAT(I)
	IF(I.EQ.1) VALV = FND1 
	IF(I.EQ.2) VALV = FND2
	CALL RELFILL('OLNK',VALV,I,IELE,1)
	ENDDO
     	    
      ENDSELECT

      
C     INDEX FOR LINK ELEMENT
	DO I = 1,2
	CALL RELFILL('OLNK',VALV,I,IELE,0)
      AOUT(I) = VALV
      ENDDO
      
      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:NOUT2) !Backup output data
      
C	---------------------
	
1000	CONTINUE


	DEALLOCATE(EDAT)


	RETURN
	END
C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE RCTOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,AOUT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
	ALLOCATABLE EDATG(:),EDATL(:)
	ALLOCATABLE ALANG1(:),ALANL1(:),ALANG2(:),ALANL2(:)
	
	DIMENSION AOUT(1)

      CALL INTFILL('FIDX',LCONF,1,LP,0) 

C	--------------------------------------------------------
	CALL LOCATN('OGSP',KSUPG,NOUT2,NSN,2)
	ALLOCATE(EDATG(NOUT2))
	ALLOCATE(ALANG1(NOUT2),ALANG2(NOUT2)) !FOR LANE POINT LOAD SORTING


	DO 1000 ISN = 1,NSN

C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	NUMDAT = NUMDAT + NOUT2
	GOTO 1000
	ENDIF
C	---------------------

	NRC = NUMLIN + ISN

      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:NOUT2) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=10) AOUT(1:NOUT2) !Read output data
          GOTO 20
10        AOUT(1:NOUT2) = 0.0D0
20        CONTINUE    
      ENDIF      
      
      
	SELECTCASE(IND)

	CASE(0)
	
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	VALV = EDATG(I)*FACT
	CALL RELFILL('OGSP',VALV,I,ISN,1)
	ENDDO

	CASE(1)
	DO I = 1,NOUT2
	CALL RELFILL('OGSP',VALV,I,ISN,0)
	EDATG(I) = VALV*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATG(1:NOUT2)
	AOUT(1:NOUT2) = EDATG(1:NOUT2)

	CASE(2)
	
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OGSP',VALV,I,ISN,0)
	EDATG(I) = EDATG(I)+VALV*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATG(1:NOUT2)
	AOUT(1:NOUT2) = EDATG(1:NOUT2)

	CASE(3)
	DO I = 1,NOUT2
	VALV = 0.0D0
	CALL RELFILL('OGSP',VALV,I,ISN,1)
	ENDDO

	CASE(4)
	EDATG(1:NOUT2) = 0.0D0

C	WRITE(LP,REC=NRC) EDATG(1:NOUT2)
	AOUT(1:NOUT2) = EDATG(1:NOUT2)

	CASE(5)
	
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OGSP',VALV,I,ISN,0)
	VALV = VALV + EDATG(I)*FACT
	CALL RELFILL('OGSP',VALV,I,ISN,1)
	ENDDO

	CASE(6)
	
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	    CALL RELFILL('OGSP',VALV,I,ISN,0)
	        IF(I.LE.NOUT2/2) THEN
	          IF( FACT*VALV.GE.EDATG(I) ) EDATG(I) = VALV*FACT
	        ENDIF
	        IF(I.GT.NOUT2/2) THEN
	          IF( FACT*VALV.LE.EDATG(I) ) EDATG(I) = VALV*FACT
	        ENDIF
	        IF(LCONF.EQ.0) EDATG(I) = VALV*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATG(1:NOUT2)
	AOUT(1:NOUT2) = EDATG(1:NOUT2)

	CASE(7)
C     NOTHING SPACIAL FOR LANE POINT LOad
      CONTINUE
      

	CASE(8)
	
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	EDATG(I) = SQRT( ABS(EDATG(I)) )*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATG(1:NOUT2)
	AOUT(1:NOUT2) = EDATG(1:NOUT2)


	CASE(9)
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	    CALL RELFILL('OGSP',VALV,I,ISN,0)
	    IF(I.LE.NOUT2/2) THEN
	      IF( VALV.GE.0.0D0 ) EDATG(I) = EDATG(I) + VALV*FACT
	    ENDIF
	    IF(I.GT.NOUT2/2) THEN
	      IF( VALV.LE.0.0D0 ) EDATG(I) = EDATG(I) + VALV*FACT
	    ENDIF
	ENDDO

C	WRITE(LP,REC=NRC) EDATG(1:NOUT2)
	AOUT(1:NOUT2) = EDATG(1:NOUT2)
	
	CASE(10)
C     NO INDEX FOR REACTION
      CONTINUE
      
     	CASE(11)
     	    NOUT22 = NOUT2/2
     	    AOUT(1       :NOUT22) = 1.0D0
     	    AOUT(1+NOUT22:NOUT2 ) =-1.0D0

	CASE(12)
	
C	READ(LP,REC=NRC)  EDATG(1:NOUT2)
	EDATG(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OGSP',VALV,I,ISN,0)
	VALV = VALV*EDATG(I)
	CALL RELFILL('OGSP',VALV,I,ISN,1)
	ENDDO
      
	ENDSELECT

      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:NOUT2) !Backup output data
      
C	---------------------

1000	CONTINUE
C	--------------------------------------------------------



	CALL LOCATN('OLSP',KSUPL,NOUT2,NSN,2)
	ALLOCATE(EDATL(NOUT2))
	ALLOCATE(ALANL1(NOUT2),ALANL2(NOUT2)) !FOR LANE POINT LOAD SORTING


	DO 2000 ISN = 1,NSN

C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	NUMDAT = NUMDAT + NOUT2
	GOTO 2000
	ENDIF
C	---------------------

	NRC = NUMLIN + ISN + NSN

      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:NOUT2) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=60) AOUT(1:NOUT2) !Read output data
          GOTO 70
60        AOUT(1:NOUT2) = 0.0D0
70        CONTINUE    
      ENDIF    
      
	SELECTCASE(IND)

	CASE(0)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	VALV = EDATL(I)*FACT
	CALL RELFILL('OLSP',VALV,I,ISN,1)
	ENDDO

	CASE(1)
	DO I = 1,NOUT2
	CALL RELFILL('OLSP',VALV,I,ISN,0)
	EDATL(I) = VALV*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATL(1:NOUT2)
	AOUT(1:NOUT2) = EDATL(1:NOUT2)

	CASE(2)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OLSP',VALV,I,ISN,0)
	EDATL(I) = EDATL(I)+VALV*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATL(1:NOUT2)
	AOUT(1:NOUT2) = EDATL(1:NOUT2)

	CASE(3)
	DO I = 1,NOUT2
	VALV = 0.0D0
	CALL RELFILL('OLSP',VALV,I,ISN,1)
	ENDDO

	CASE(4)
	EDATL(1:NOUT2) = 0.0D0

C	WRITE(LP,REC=NRC) EDATL(1:NOUT2)
	AOUT(1:NOUT2) = EDATL(1:NOUT2)

	CASE(5)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OLSP',VALV,I,ISN,0)
	VALV = VALV + EDATL(I)*FACT
	CALL RELFILL('OLSP',VALV,I,ISN,1)
	ENDDO

	CASE(6)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	    CALL RELFILL('OLSP',VALV,I,ISN,0)
	        IF(I.LE.NOUT2/2) THEN
	          IF( FACT*VALV.GE.EDATL(I) ) EDATL(I) = VALV*FACT
	        ENDIF
	        IF(I.GT.NOUT2/2) THEN
	          IF( FACT*VALV.LE.EDATL(I) ) EDATL(I) = VALV*FACT
	        ENDIF
	        IF(LCONF.EQ.0) EDATL(I) = VALV*FACT	
	ENDDO

C	WRITE(LP,REC=NRC) EDATL(1:NOUT2)
	AOUT(1:NOUT2) = EDATL(1:NOUT2)

	CASE(7)
C     NOTHING SPACIAL FOR LANE POINT LOad
      CONTINUE
      

	CASE(8)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	EDATL(I) = SQRT( ABS(EDATL(I)) )*FACT
	ENDDO

C	WRITE(LP,REC=NRC) EDATL(1:NOUT2)
	AOUT(1:NOUT2) = EDATL(1:NOUT2)


	CASE(9)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	    CALL RELFILL('OLSP',VALV,I,ISN,0)
	    IF(I.LE.NOUT2/2) THEN
	      IF( VALV.GE.0.0D0 ) EDATL(I) = EDATL(I)+VALV*FACT
	    ENDIF
	    IF(I.GT.NOUT2/2) THEN
	      IF( VALV.LE.0.0D0 ) EDATL(I) = EDATL(I)+VALV*FACT
	    ENDIF
	ENDDO

C	WRITE(LP,REC=NRC) EDATL(1:NOUT2)
	AOUT(1:NOUT2) = EDATL(1:NOUT2)

	CASE(10)
C     NO INDEX FOR REACTION
      CONTINUE
            
     	CASE(11)
     	    NOUT22 = NOUT2/2
     	    AOUT(1       :NOUT22) = 1.0D0
     	    AOUT(1+NOUT22:NOUT2 ) =-1.0D0

	CASE(12)
	
C	READ(LP,REC=NRC)  EDATL(1:NOUT2)
	EDATL(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OLSP',VALV,I,ISN,0)
	VALV = VALV*EDATL(I)
	CALL RELFILL('OLSP',VALV,I,ISN,1)
	ENDDO
     	    
      ENDSELECT

      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:NOUT2) !Backup output data
      
C	---------------------

2000	CONTINUE
C	--------------------------------------------------------


	DEALLOCATE(EDATG)
	DEALLOCATE(ALANG1,ALANG2) 
	DEALLOCATE(EDATL)
	DEALLOCATE(ALANL1,ALANL2) 



	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================
	SUBROUTINE DISOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,AOUT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
	ALLOCATABLE EDAT(:)
	DIMENSION AOUT(1)
	
	CALL LOCATN('ONDS',KDISP,NOUT2,NSN,2)
	ALLOCATE(EDAT(NOUT2))

      CALL INTFILL('FIDX',LCONF,1,LP,0) 

C	--------------------------------------------------------
	DO 1000 ISN = 1,NSN

C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	NUMDAT = NUMDAT + NOUT2
	GOTO 1000
      ENDIF
C	---------------------
      
	NRC = NUMLIN + ISN

      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:NOUT2) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=10) AOUT(1:NOUT2) !Read output data
          GOTO 20
10        AOUT(1:NOUT2) = 0.0D0
20        CONTINUE    
      ENDIF         
      
	SELECTCASE(IND)

	CASE(0)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	VALV = EDAT(I)*FACT
	CALL RELFILL('ONDS',VALV,I,ISN,1)
	ENDDO

	CASE(1)
	DO I = 1,NOUT2
	CALL RELFILL('ONDS',VALV,I,ISN,0)
	EDAT(I) = VALV*FACT
	ENDDO
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)



	CASE(2)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('ONDS',VALV,I,ISN,0)
	EDAT(I) = EDAT(I)+VALV*FACT
	ENDDO
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)


	CASE(3)
	DO I = 1,NOUT2
	VALV = 0.0D0
	CALL RELFILL('ONDS',VALV,I,ISN,1)
	ENDDO

	CASE(4)
	EDAT(1:NOUT2) = 0.0D0
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)


	CASE(5)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('ONDS',VALV,I,ISN,0)
	VALV = VALV + EDAT(I)*FACT
	CALL RELFILL('ONDS',VALV,I,ISN,1)
	ENDDO

	CASE(6)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	    CALL RELFILL('ONDS',VALV,I,ISN,0)
	        IF(I.LE.NOUT2/2) THEN
	          IF( FACT*VALV.GE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(I.GT.NOUT2/2) THEN
	          IF( FACT*VALV.LE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(LCONF.EQ.0) EDAT(I) = VALV*FACT	
	ENDDO
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)



	CASE(7)
C     NOTHING SPACIAL FOR LANE POINT LOad
      CONTINUE
      

	CASE(8)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	EDAT(I) = SQRT( ABS(EDAT(I)) )*FACT
	ENDDO
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(9)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	    CALL RELFILL('ONDS',VALV,I,ISN,0)
	    IF(I.LE.NOUT2/2) THEN
	      IF( VALV.GE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF
	    IF(I.GT.NOUT2/2) THEN
	      IF( VALV.LE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF	
	ENDDO
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(10)
C     NO INDEX FOR DISPLACEMENT
      CONTINUE
            
     	CASE(11)
     	    NOUT22 = NOUT2/2
     	    AOUT(1       :NOUT22) = 1.0D0
     	    AOUT(1+NOUT22:NOUT2 ) =-1.0D0

	CASE(12)
	
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('ONDS',VALV,I,ISN,0)
	VALV = VALV*EDAT(I)
	CALL RELFILL('ONDS',VALV,I,ISN,1)
	ENDDO
      
	ENDSELECT


      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:NOUT2) !Backup output data
      
C	---------------------

1000	CONTINUE
C	--------------------------------------------------------
	

	DEALLOCATE(EDAT)

	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================
	SUBROUTINE SPGOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,AOUT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=================================================================
	DIMENSION AOUT(1)
	ALLOCATABLE EDAT(:)
	
	CALL LOCATN('OGSS',KGSS,NOUT2,NSS,2)
	ALLOCATE(EDAT(NOUT2))

      CALL INTFILL('FIDX',LCONF,1,LP,0) 


C	--------------------------------------------------------
	DO 1000 ISN = 1,NSS

C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	NUMDAT = NUMDAT + NOUT2
	GOTO 1000
	ENDIF
C	---------------------

	NRC = NUMLIN + ISN

      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:NOUT2) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=10) AOUT(1:NOUT2) !Read output data
          GOTO 20
10        AOUT(1:NOUT2) = 0.0D0
20        CONTINUE    
      ENDIF  
      
	SELECTCASE(IND)

	CASE(0)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	VALV = EDAT(I)*FACT
	IF(I.EQ.1) VALV = FND1 
	CALL RELFILL('OGSS',VALV,I,ISN,1)
	ENDDO

	CASE(1)
	DO I = 1,NOUT2
	CALL RELFILL('OGSS',VALV,I,ISN,0)
	IF(I.EQ.1) FND1 = VALV
	EDAT(I) = VALV*FACT
	ENDDO
	EDAT(1) = FND1
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(2)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	DO I = 1,NOUT2
	CALL RELFILL('OGSS',VALV,I,ISN,0)
	IF(I.EQ.1) FND1 = VALV
	EDAT(I) = EDAT(I)+VALV*FACT
	ENDDO
	EDAT(1) = FND1
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(3)
	DO I = 1,NOUT2
	VALV = 0.0D0
	CALL RELFILL('OGSS',VALV,I,ISN,1)
	ENDDO

	CASE(4)
	EDAT(1:NOUT2) = 0.0D0
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(5)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	CALL RELFILL('OGSS',VALV,I,ISN,0)
	IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	VALV = VALV + EDAT(I)*FACT
	IF(I.EQ.1) VALV = FND1 
	CALL RELFILL('OGSS',VALV,I,ISN,1)
	ENDDO

	CASE(6)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)

      FND1 = EDAT(1)
	DO I = 1,NOUT2
	    CALL RELFILL('OGSS',VALV,I,ISN,0)
	        IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	        IF(I.LE.NOUT2/2) THEN
	          IF( FACT*VALV.GE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(I.GT.NOUT2/2) THEN
	          IF( FACT*VALV.LE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(LCONF.EQ.0) EDAT(I) = VALV*FACT
	ENDDO
	EDAT(1) = FND1
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(7)
C     NOTHING SPACIAL FOR LANE POINT LOad
      CONTINUE


	CASE(8)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	EDAT(I) = SQRT( ABS(EDAT(I)) )*FACT
	ENDDO
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(9)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	    CALL RELFILL('OGSS',VALV,I,ISN,0)
	    IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	    IF(I.LE.NOUT2/2) THEN
	      IF( VALV.GE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF
	    IF(I.GT.NOUT2/2) THEN
	      IF( VALV.LE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF	
	ENDDO
	EDAT(1) = FND1
	
C	WRITE(LP,REC=NRC) EDAT(1:NOUT2)
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(10)
C     INDEX FOR GLOBAL SPRING SUPPORT-- SKIP...ALWAY DO AT THE END OF LOOP
            
     	CASE(11)
     	    NOUT22 = NOUT2/2
     	    AOUT(1       :NOUT22) = 1.0D0
     	    AOUT(1+NOUT22:NOUT2 ) =-1.0D0

	CASE(12)
C	READ(LP,REC=NRC)  EDAT(1:NOUT2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	CALL RELFILL('OGSS',VALV,I,ISN,0)
	IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	VALV = VALV*EDAT(I)
	IF(I.EQ.1) VALV = FND1 
	CALL RELFILL('OGSS',VALV,I,ISN,1)
	ENDDO
		
	ENDSELECT


C     INDEX FOR GLOBAL SPRING SUPPORT
!	CALL RELFILL('OGSS',VALV,1,ISN,0)
!	AOUT(LD1+1-1) = VALV
      
!      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:NOUT2) !Backup output data

C	---------------------

1000	CONTINUE
C	--------------------------------------------------------

	DEALLOCATE(EDAT)
	

	RETURN
	END
C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE SPLOPER(LP,IND,FACT,IREAD,NUMLIN,NUMDAT,AOUT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=================================================================
	DIMENSION AOUT(1)
	ALLOCATABLE EDAT(:)
	
	CALL LOCATN('OLSS',KLSS,NOUT2,NLSS,2)
	ALLOCATE(EDAT(NOUT2))

      CALL INTFILL('FIDX',LCONF,1,LP,0) 

C	--------------------------------------------------------
	DO 1000 ISN = 1,NLSS

C	---------------------
	IF(IREAD.EQ.1) THEN
	NUMLIN = NUMLIN + 1
	NUMDAT = NUMDAT + NOUT2
	GOTO 1000
	ENDIF
C	---------------------

	NRC = NUMLIN + ISN

      IF(IREAD.EQ.2.OR.LP.EQ.0) THEN
          AOUT(1:NOUT2) = 0.0D0
      ELSE
          READ(LP,REC=NRC,ERR=10) AOUT(1:NOUT2) !Read output data
          GOTO 20
10        AOUT(1:NOUT2) = 0.0D0
20        CONTINUE    
      ENDIF  
      
	SELECTCASE(IND)

	CASE(0)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	VALV = EDAT(I)*FACT
	IF(I.EQ.1) VALV = FND1 
	CALL RELFILL('OLSS',VALV,I,ISN,1)
	ENDDO

	CASE(1)
	DO I = 1,NOUT2
	CALL RELFILL('OLSS',VALV,I,ISN,0)
	IF(I.EQ.1) FND1 = VALV
	EDAT(I) = VALV*FACT
	ENDDO
	EDAT(1) = FND1
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(2)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	CALL RELFILL('OLSS',VALV,I,ISN,0)
	IF(I.EQ.1) FND1 = VALV
	EDAT(I) = EDAT(I)+VALV*FACT
	ENDDO
	EDAT(1) = FND1
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(3)
	DO I = 1,NOUT2
	VALV = 0.0D0
	CALL RELFILL('OLSS',VALV,I,ISN,1)
	ENDDO

	CASE(4)
	EDAT(1:NOUT2) = 0.0D0
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)


	CASE(5)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	CALL RELFILL('OLSS',VALV,I,ISN,0)
	IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	VALV = VALV + EDAT(I)*FACT
	IF(I.EQ.1) VALV = FND1 
	CALL RELFILL('OLSS',VALV,I,ISN,1)
	ENDDO

	CASE(6)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)

	FND1 = EDAT(1)
	DO I = 1,NOUT2
	    CALL RELFILL('OLSS',VALV,I,ISN,0)
	        IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	        IF(I.LE.NOUT2/2) THEN
	          IF( FACT*VALV.GE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(I.GT.NOUT2/2) THEN
	          IF( FACT*VALV.LE.EDAT(I) ) EDAT(I) = VALV*FACT
	        ENDIF
	        IF(LCONF.EQ.0) EDAT(I) = VALV*FACT	
	ENDDO
	EDAT(1) = FND1
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(7)
C     NOTHING SPACIAL FOR LANE POINT LOad
      CONTINUE
      

	CASE(8)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	DO I = 1,NOUT2
	EDAT(I) = SQRT( ABS(EDAT(I)) )*FACT
	ENDDO
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)

	CASE(9)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	    CALL RELFILL('OLSS',VALV,I,ISN,0)
	    IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	    IF(I.LE.NOUT2/2) THEN
	      IF( VALV.GE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF
	    IF(I.GT.NOUT2/2) THEN
	      IF( VALV.LE.0.0D0 ) EDAT(I) = EDAT(I)+VALV*FACT
	    ENDIF
	ENDDO
	EDAT(1) = FND1
	
	AOUT(1:NOUT2) = EDAT(1:NOUT2)
	
	CASE(10)
C     INDEX FOR LOCAL SPRING SUPPORT -- SKIP...ALWAY RECORD AT END OF LOOP
            
     	CASE(11)
     	    NOUT22 = NOUT2/2
     	    AOUT(1       :NOUT22) = 1.0D0
     	    AOUT(1+NOUT22:NOUT2 ) =-1.0D0

	CASE(12)
	EDAT(1:NOUT2) = AOUT(1:NOUT2)
	
	FND1 = EDAT(1)
	DO I = 1,NOUT2
	CALL RELFILL('OLSS',VALV,I,ISN,0)
	IF(FND1.EQ.0.0D0.AND.I.EQ.1) FND1 = VALV 
	VALV = VALV*EDAT(I)
	IF(I.EQ.1) VALV = FND1 
	CALL RELFILL('OLSS',VALV,I,ISN,1)
	ENDDO
	
	ENDSELECT

C     INDEX FOR LOCAL SPRING SUPPORT
!	CALL RELFILL('OLSS',VALV,1,ISN,0)
!	AOUT(LD1+1-1) = VALV
      
      IF(IREAD.NE.3.AND.LP.NE.0) WRITE(LP,REC=NRC) AOUT(1:NOUT2) !Backup output data
C	---------------------

1000	CONTINUE
C	--------------------------------------------------------


	DEALLOCATE(EDAT)
	

	RETURN
	END

C	=====================================================================
C	=====================================================================
C	=====================================================================

	SUBROUTINE BLOCKSORT(AA,L1,L2,LP,NSTEP,OPTN)   
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*4 OPTN
      
C     ----------------------------------------------------------------
      ALLOCATABLE AOUT(:)
      DIMENSION AA(1)
C     ----------------------------------------------------------------

	CALL INTFILL('NPLN',NL1   ,1,1 ,0)  
	CALL INTFILL('NPLN',NL2   ,1,2 ,0)  
	CALL INTFILL('NPLN',NL3   ,1,3 ,0)  
	CALL INTFILL('NPLN',NL4   ,1,4 ,0)  
	CALL INTFILL('NPLN',NL5   ,1,5 ,0)  
	CALL INTFILL('NPLN',NL6   ,1,6 ,0)  
	CALL INTFILL('NPLN',NUMLIN,1,10,0)
	
	CALL INTFILL('NPLN',NLD1  ,1,11,0)  
	CALL INTFILL('NPLN',NLD2  ,1,12,0)  
	CALL INTFILL('NPLN',NLD3  ,1,13,0)  
	CALL INTFILL('NPLN',NLD4  ,1,14,0)  
	CALL INTFILL('NPLN',NLD5  ,1,15,0)  
	CALL INTFILL('NPLN',NLD6  ,1,16,0)  
	CALL INTFILL('NPLN',NUMDAT,1,20,0)
	 
      IF(NSTEP.GT.0) THEN 
	    NL1 = NL1+NUMLIN*(NSTEP-1)
	    NL2 = NL2+NUMLIN*(NSTEP-1)
	    NL3 = NL3+NUMLIN*(NSTEP-1)
	    NL4 = NL4+NUMLIN*(NSTEP-1)
	    NL5 = NL5+NUMLIN*(NSTEP-1)
	    NL6 = NL6+NUMLIN*(NSTEP-1)
	ENDIF
      
      ALLOCATE(AOUT(NUMDAT))
      

      LEN = L2 - L1 + 1
            
      IF(OPTN.EQ.'SORT') GOTO 50
      IF(OPTN.EQ.'WRIT') GOTO 55
      

      KREC = NSTEP  
      AOUT(L1:L2) = 0.0D0
	CALL PARLWRIT(LP,KREC,AOUT,NUMDAT,LERR,'READ')         
      AA(1:LEN) = AOUT(L1:L2)
      
            
      IF(OPTN.EQ.'CALL') GOTO 80
      
      
50    AOUT(1:NUMDAT) = 0.0D0 

	IND = 11 ; IREAD = 0 ; FACT = 1.0D0 !TRANSFER DATA TO MEMORY
	CALL GRPOPER(LP,IND,FACT,IREAD,NL1,NLD1,AOUT(NLD1))
	CALL LIKOPER(LP,IND,FACT,IREAD,NL2,NLD2,AOUT(NLD2))
	CALL RCTOPER(LP,IND,FACT,IREAD,NL3,NLD3,AOUT(NLD3))
	CALL DISOPER(LP,IND,FACT,IREAD,NL4,NLD4,AOUT(NLD4))
	CALL SPGOPER(LP,IND,FACT,IREAD,NL5,NLD5,AOUT(NLD5))
	CALL SPLOPER(LP,IND,FACT,IREAD,NL6,NLD6,AOUT(NLD6))
	
	AA(1:LEN) = AOUT(L1:L2)
      GOTO 80
      
	           
55    AOUT(1:NUMDAT) = 0.0D0 
      KREC = NSTEP  
	CALL PARLWRIT(LP,KREC,AOUT,NUMDAT,LERR,'READ')   
	IF(LERR.NE.0) GOTO 60
	GOTO 70
60    AOUT(1:NUMDAT) = 0.0D0
      CALL PARLWRIT(LP,KREC,AOUT,NUMDAT,LERR,'WRIT') 
70    CONTINUE

      AOUT(L1:L2) = AA(1:LEN)
      
      CALL PARLWRIT(LP,KREC,AOUT,NUMDAT,LERR,'WRIT') 

	LCONF = 1 !WRITE DATA TO FILE
      CALL INTFILL('FIDX',LCONF,1,LP,1) 

80    CONTINUE
      
      DEALLOCATE(AOUT)
      


      RETURN
      END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE ELPOUT (OPT_OFF)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*4 OPT_OFF
C     ---------------------------------------------------
C     ---------------------------------------------------
	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     1              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM
      COMMON /ELEM/ NAME(2),ITYPE,ISTYP,NLOPT,MTMOD,NSINC,ITOLEY,
     1              NELE,NMPS,NGPS,NMP,NGP,NNM,NEX,NCO,NNF,NWG,NEFC,
     2              NPT,NWA,NWS,KEG,MEL,NNO,NEF,NELTOT,NMV,MTYP,ISECT
      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON A(9000000),IA(9000000)


      GOTO (100,120,100,100,150,160,100,180,190,200,210,
	1	  100,213,214,215,216), ITYPE
	RETURN

C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
120	CALL STPOUT (KEG)
	RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
150	CALL BMPOUT (A(LGP),IA(LGS),KEG,LCS,OPT_OFF)
	RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
160	CALL MEPOUT (KEG,IA(LEX),NEX)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
180	CALL MCPOUT (KEG,IA(LEX),NEX)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
190	CALL MPPOUT (KEG,IA(LEX),NEX)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
200	CALL SOPOUT (KEG,IA(LEX),NEX)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
210	CALL SCPOUT (KEG,IA(LEX),NEX)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
213	CALL F2POUT (KEG)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
214	CALL F3POUT (KEG)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
215	CALL H2POUT (KEG)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------
216	CALL H3POUT (KEG)
      RETURN
C	-------------------------------------------------------------------
C	-------------------------------------------------------------------

100	CONTINUE

	RETURN

      END
C	=====================================================================
C	=====================================================================
C	=====================================================================

      SUBROUTINE STPOUT(KEG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------
	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WA(:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WA(NWA))

	
C	-----------------------------
	IF(ISTYP.NE.4) THEN 

	DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WA,'RED')
	EDAT    = 0.0D0
	EDAT(1) = WA(1)


          READ(NFL1,REC=IEL) AF1(1:N1) 
      
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
          ENDDO	

          
          WRITE(NFL1,REC=IEL) AF1(1:N1) 
          
	ENDDO

	ENDIF
C	-----------------------------


C	-----------------------------
	IF(ISTYP.EQ.4) THEN !FOR SPC CABLE

	DO IEL=1,NELE
	CALL ADREWT(KEG,IEL,WA,'RED')
	EDAT = 0.0D0
	EDAT(1) = WA(1)
	EDAT(2) = WA(2)
	EDAT(3) = WA(3)

          READ(NFL1,REC=IEL) AF1(1:N1) 
          
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	

          WRITE(NFL1,REC=IEL) AF1(1:N1) 
	ENDDO

	ENDIF
C	-----------------------------
	
	DEALLOCATE(AF1,EDAT,WA)

      RETURN
      END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE BMPOUT(PROPG,IGSET,KEG,LCS,OPT_OFF)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*4 OPT_OFF
C     ---------------------------------------------------------------------

	DIMENSION PROPG(1),IGSET(1)
	DIMENSION FIN(7)
	DIMENSION SCT(2)


	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:)


	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !MGAS  
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',N3   ,3 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !	
	IF (OPT_OFF.EQ."SKIP") CALL INTFILL('OGRF',NFL_SMOOTH ,13,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM
      IF (OPT_OFF.EQ."CALC") CALL INTFILL('OGRF',NFL_SMOOTH ,20,IEG,0) !ONLY FOR FRAME ELEMENT FOR SMOOOTH LINE DIAGRAM OFFSHORE
	ALLOCATE(AF1(N1),EDAT(NOUT))


	
	CALL INTFILL('FRMP',NP_SMH,1,IEG,0)
	CALL INTFILL('FRMP',MST   ,2,IEG,0)   !NUMBER OF MAXIMUM STRESS POINT
	CALL INTFILL('FRMP',MFC   ,3,IEG,0)   !NUMBER OF MAXIMUM FORCE COMPONENT
	NP2 = NP_SMH + 2


      DO IEL=1,NELE

C	--------------
C	ISET = IGSET(IEL)
C	SCT(1) = PROPG(1+NGP*(ISET-1))  !SC
C	SCT(2) = PROPG(2+NGP*(ISET-1))  !TC

	EDAT = 0.0D0
	DO IN = 1,2+NP_SMH
	NUM = LENGTH*(IN-1)

	IRC = IN + NP2*(IEL-1) + 2*NP_SMH*NELE*LCS
	READ(NFL_SMOOTH,REC=IRC) FIN(1:7)

      CALL STORFORC(FIN,EDAT(1+NUM))
	ENDDO


	NIJ = 1
	IN  = 1
	NUM = LENGTH*(IN-1)
	CALL XFSECTION(IEG,IEL,NIJ)
	CALL FRMSTRS( EDAT(1+NUM+MFC),EDAT(1+NUM),KEG)

	NIJ = NPT
	IN  = 2+NP_SMH
	NUM = LENGTH*(IN-1)
	CALL XFSECTION(IEG,IEL,NIJ)
	CALL FRMSTRS( EDAT(1+NUM+MFC),EDAT(1+NUM),KEG)
	

C     TRANSFORM TO CENTROID
	DO IN = 1,2+NP_SMH
	NUM = LENGTH*(IN-1)
	NIJ = IN
	CALL XFSECTION(IEG,IEL,NIJ)
	CALL CENFORCE(EDAT(1+NUM),IEG)
	ENDDO
	
	
	DO IST = 1,MST
	IN  = 1
	NUM = LENGTH*(IN-1)
	S1  = EDAT(IST+NUM+MFC)
	IN  = 2+NP_SMH
	NUM = LENGTH*(IN-1)
	S2  = EDAT(IST+NUM+MFC)
	DO I = 1,NP_SMH
	IN = I+1
	FAC = 1.0D0*(IN-1)/(2+NP_SMH-1)
	H1  = 1.0D0-FAC
	H2  = FAC
	NUM = LENGTH*(IN-1)
	EDAT(IST+NUM+MFC) = S1*H1 + S2*H2
	ENDDO
	ENDDO

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1) 
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO		
          WRITE(NFL1,REC=IEL) AF1(1:N1) 
C	--------------

	ENDDO

	DEALLOCATE(AF1,EDAT)


      RETURN

      END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE MEPOUT(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     --------------------------------------------------------------
	DIMENSION NPOGS(27),SIG(6)

	DIMENSION NODEX(MEX,1),GPSO(2,9),H(9),HD(2,9)
	
	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)
	
	ALLOCATABLE EGMAT(:,:),EXMAT(:,:),EXMATI(:,:),SGVEC(:,:),STVEC(:,:)
	

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !


      SELECTCASE(ISTYP)
      CASE(0,1,2)   !8 NODE
          SELECTCASE(NPT)
            CASE(4)
	        NPOGS(1:4) = [4,2,1,3]
	         GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963]
	         GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	         GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	         GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]
	      CASE(9)
	        NPOGS(1:9) = [9,3,1,7,6,2,4,8,5]
	         GPSO(1:2,1) = [-0.77459666924148,-0.77459666924148]
	         GPSO(1:2,2) = [-0.77459666924148, 0.00000000000000]
	         GPSO(1:2,3) = [-0.77459666924148,+0.77459666924148]
	         GPSO(1:2,4) = [ 0.00000000000000,-0.77459666924148]
	         GPSO(1:2,5) = [ 0.00000000000000, 0.00000000000000]
	         GPSO(1:2,6) = [ 0.00000000000000,+0.77459666924148]
	         GPSO(1:2,7) = [+0.77459666924148,-0.77459666924148]
	         GPSO(1:2,8) = [+0.77459666924148, 0.00000000000000]
	         GPSO(1:2,9) = [+0.77459666924148,+0.77459666924148]
	    ENDSELECT     
      CASE(3,4,5)   !4 EAS
	NPOGS(1:4) = [4,2,1,3]
	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963]
	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]
      CASE DEFAULT       
	 RETURN
	ENDSELECT


	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))
	
	
C	--------------------------------------------------------------
C	--------------------------------------------------------------
	ALLOCATE(EGMAT(NPT,NNM),EXMAT(NNM,NNM),EXMATI(NNM,NNM))
	
	ALLOCATE(SGVEC(NPT,LENGTH),STVEC(NNM,LENGTH))


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

C	--------------
      DO IPT=1,NPT
      
C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))

      SELECTCASE(ISTYP)
      CASE(0,1,2)   !8 NODE
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(3,4,5)   !4 EAS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------
      
	I1 = NWG*(NPOGS(IPT)-1) + 1
	SIG(1:6) = 0.0D0
	SIG(1) = WOREL(I1  )
	SIG(2) = WOREL(I1+1)
	SIG(4) = WOREL(I1+2)
	SIG(3) = WOREL(I1+3)
	CALL POSVMS(SIG,VMISE)
	NUM = LENGTH*(IPT-1)
	EDAT(NUM + 1) = SIG(1)
	EDAT(NUM + 2) = SIG(2)
	EDAT(NUM + 3) = SIG(3) !SIGMA Z
	EDAT(NUM + 4) = SIG(4)
	EDAT(NUM + 5) = VMISE
	
      SGVEC(IPT,1) = SIG(1)    !FOR EXTRAPOLATION
      SGVEC(IPT,2) = SIG(2)    !FOR EXTRAPOLATION
      SGVEC(IPT,3) = SIG(3)    !FOR EXTRAPOLATION
      SGVEC(IPT,4) = SIG(4)    !FOR EXTRAPOLATION
      SGVEC(IPT,5) = VMISE     !FOR EXTRAPOLATION
      
	ENDDO
C	--------------

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
      EXMAT = MATMUL(TRANSPOSE(EGMAT),EGMAT)
	CALL INVMATRIX(EXMAT,EXMATI,NNM)
	STVEC = MATMUL(EXMATI,MATMUL(TRANSPOSE(EGMAT),SGVEC))
	DO INM = 1,NNM
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC(INM,1:LENGTH) 
	ENDDO
C     --------------------------------

          READ(NFL1,REC=IEL) AF1(1:N1) 
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1) 		
C	--------------	

	ENDDO

	
	DEALLOCATE(AF1,EDAT,WOREL)
	
	DEALLOCATE(EXMAT,EXMATI,STVEC,EGMAT,SGVEC)

	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE MCPOUT(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     --------------------------------------------------------------
	DIMENSION NPOGS(27),SIG(6)

	DIMENSION NODEX(MEX,1),GPSO(2,9),H(9),HD(2,9)
	
	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)
	
	ALLOCATABLE EGMAT(:,:),EXMAT(:,:),EXMATI(:,:),SGVEC(:,:),STVEC(:,:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))

C	--------------------------------------------------------------
C	--------------------------------------------------------------
	ALLOCATE(EGMAT(NPT,NNM),EXMAT(NNM,NNM),EXMATI(NNM,NNM))
	
      SELECTCASE(ISTYP)
      CASE(3,4,5)   !4 EAS
          SELECTCASE(NPT)
            CASE(4)
	        NPOGS(1:4) = [4,2,1,3]
	         GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963]
	         GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	         GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	         GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]
	      CASE(9)
	        NPOGS(1:9) = [9,3,1,7,6,2,4,8,5]
	         GPSO(1:2,1) = [-0.77459666924148,-0.77459666924148]
	         GPSO(1:2,2) = [-0.77459666924148, 0.00000000000000]
	         GPSO(1:2,3) = [-0.77459666924148,+0.77459666924148]
	         GPSO(1:2,4) = [ 0.00000000000000,-0.77459666924148]
	         GPSO(1:2,5) = [ 0.00000000000000, 0.00000000000000]
	         GPSO(1:2,6) = [ 0.00000000000000,+0.77459666924148]
	         GPSO(1:2,7) = [+0.77459666924148,-0.77459666924148]
	         GPSO(1:2,8) = [+0.77459666924148, 0.00000000000000]
	         GPSO(1:2,9) = [+0.77459666924148,+0.77459666924148]
	    ENDSELECT     
      CASE DEFAULT       
	 RETURN
	ENDSELECT

	ALLOCATE(SGVEC(NPT,LENGTH),STVEC(NNM,LENGTH))


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

C	--------------
      DO IPT=1,NPT
      
C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))

      SELECTCASE(ISTYP)
      CASE(3,4,5)   !4 EAS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------

	I1 = NWG*(NPOGS(IPT)-1) + 1
	SIG(1:6) = 0.0D0
	SIG(1) = WOREL(I1  )
	SIG(2) = WOREL(I1+1)
	SIG(4) = WOREL(I1+2)
	SIG(3) = WOREL(I1+3)

	CALL POSVMS(SIG,VMISE)
	NUM = LENGTH*(IPT-1)
	EDAT(NUM + 1) = SIG(1)
	EDAT(NUM + 2) = SIG(2)
	EDAT(NUM + 3) = SIG(3) !SIGMA Z
	EDAT(NUM + 4) = SIG(4)
	EDAT(NUM + 5) = VMISE
	
      SGVEC(IPT,1) = SIG(1)    !FOR EXTRAPOLATION
      SGVEC(IPT,2) = SIG(2)    !FOR EXTRAPOLATION
      SGVEC(IPT,3) = SIG(3)    !FOR EXTRAPOLATION
      SGVEC(IPT,4) = SIG(4)    !FOR EXTRAPOLATION
      SGVEC(IPT,5) = VMISE     !FOR EXTRAPOLATION
      
	ENDDO
C	--------------

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
      EXMAT = MATMUL(TRANSPOSE(EGMAT),EGMAT)
	CALL INVMATRIX(EXMAT,EXMATI,NNM)
	STVEC = MATMUL(EXMATI,MATMUL(TRANSPOSE(EGMAT),SGVEC))
	DO INM = 1,NNM
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC(INM,1:LENGTH) 
	ENDDO
C     --------------------------------

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1) 
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1) 	
C	--------------	

	ENDDO
	
	DEALLOCATE(AF1,EDAT,WOREL)
	DEALLOCATE(EXMAT,EXMATI,STVEC,EGMAT,SGVEC)

	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE MPPOUT(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------
	DIMENSION NPOGS(27)

	DIMENSION NPM(10),NPI(10),SIGT(8)
	
	DIMENSION NODEX(MEX,1),GPSO(2,9),H(9),HD(2,9)
	
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)
	ALLOCATABLE EGMAT(:,:),EXMAT(:,:),EXMATI(:,:),SGVEC(:,:),STVEC(:,:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))
	
C     -------------------------------
C     -------------------------------

	ALLOCATE(EGMAT(NPT,NNM),EXMAT(NNM,NNM),EXMATI(NNM,NNM))
	
      SELECTCASE(ISTYP)
      CASE(1)   !4 ANS
	NPOGS(1:4) = [4,2,1,3]
	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963]
	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]
      CASE(3)   !8 ANS
	NPOGS(1:9) = [9,3,1,7,6,2,4,8,5]
	 GPSO(1:2,1) = [-0.77459666924148,-0.77459666924148]
	 GPSO(1:2,2) = [-0.77459666924148, 0.00000000000000]
	 GPSO(1:2,3) = [-0.77459666924148,+0.77459666924148]
	 GPSO(1:2,4) = [ 0.00000000000000,-0.77459666924148]
	 GPSO(1:2,5) = [ 0.00000000000000, 0.00000000000000]
	 GPSO(1:2,6) = [ 0.00000000000000,+0.77459666924148]
	 GPSO(1:2,7) = [+0.77459666924148,-0.77459666924148]
	 GPSO(1:2,8) = [+0.77459666924148, 0.00000000000000]
	 GPSO(1:2,9) = [+0.77459666924148,+0.77459666924148]
      CASE(4)   !4 QSI
	NPOGS(1:4) = [1,2,3,4]
	 GPSO(1:2,1) = [+1.0D0,+1.0D0]
	 GPSO(1:2,2) = [-1.0D0,+1.0D0]
	 GPSO(1:2,3) = [-1.0D0,-1.0D0]
	 GPSO(1:2,4) = [+1.0D0,-1.0D0]
      CASE(11)  !3 QSI
	NPOGS(1:3) = [1,2,3]
	 GPSO(1:2,1) = [ 0.0D0, 0.0D0]
	 GPSO(1:2,2) = [+1.0D0, 0.0D0]
	 GPSO(1:2,3) = [ 0.0D0,+1.0D0]
      CASE(12)  !9 ANS
	NPOGS(1:9) = [9,3,1,7,6,2,4,8,5]
	 GPSO(1:2,1) = [-0.77459666924148,-0.77459666924148]
	 GPSO(1:2,2) = [-0.77459666924148, 0.00000000000000]
	 GPSO(1:2,3) = [-0.77459666924148,+0.77459666924148]
	 GPSO(1:2,4) = [ 0.00000000000000,-0.77459666924148]
	 GPSO(1:2,5) = [ 0.00000000000000, 0.00000000000000]
	 GPSO(1:2,6) = [ 0.00000000000000,+0.77459666924148]
	 GPSO(1:2,7) = [+0.77459666924148,-0.77459666924148]
	 GPSO(1:2,8) = [+0.77459666924148, 0.00000000000000]
	 GPSO(1:2,9) = [+0.77459666924148,+0.77459666924148]
      CASE(13)   ! SHEAR WALL ELEMENT
	NPOGS(1:4) = [4,2,1,3]
	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963]
	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]     
	CASE DEFAULT
	 GOTO 5000
	ENDSELECT

	ALLOCATE(SGVEC(NPT,LENGTH),STVEC(NNM,LENGTH))
	

      DO IEL=1,NELE 
          
	CALL ADREWT(KEG,IEL,WOREL,'RED')

	IF(MTMOD.EQ.1) THEN
      DO IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES OF SHELL
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))

      SELECTCASE(ISTYP)
      CASE(1)   !4 ANS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(3)   !8 ANS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(4)   !4 QSI
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(11)  !3 QSI
	CALL SHAP2D3(RI,SI,H,HD,NNM)
      CASE(12)  !9 ANS
	CALL SHAP2D9(RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(13)   !SHEAR WALL
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)      
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------

	NUM = (8+6*3)*(IPT-1)
	I1 = NWG*(NPOGS(IPT)-1) + 1	

	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1   ),SIGT,'RESULT')

	EDAT(NUM + 1) = SIGT(1)  !M
	EDAT(NUM + 2) = SIGT(2)
	EDAT(NUM + 3) = SIGT(3)  !B
	EDAT(NUM + 4) = SIGT(4)
	EDAT(NUM + 5) = SIGT(5)
	EDAT(NUM + 6) = SIGT(6)  !S
	EDAT(NUM + 7) = SIGT(7)
	EDAT(NUM + 8) = SIGT(8)

      SGVEC(IPT,1:8) = SIGT(1:8)    !FOR EXTRAPOLATION
      
	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1+8 ),SIGT,'FIBER6')
	EDAT(NUM + 9 ) = SIGT(1)
	EDAT(NUM + 10) = SIGT(2)
	EDAT(NUM + 11) = SIGT(3)
	EDAT(NUM + 12) = SIGT(4)
	EDAT(NUM + 13) = SIGT(5)
	EDAT(NUM + 14) = SIGT(6)
	
	IFI = 1 !LAYER 1 (BOTTOM LAYER)
      SGVEC(IPT,8+6*(IFI-1)+1:8+6*(IFI-1)+6) = SIGT(1:6)    !FOR EXTRAPOLATION
	
	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1+14),SIGT,'FIBER6')
	EDAT(NUM + 15) = SIGT(1)
	EDAT(NUM + 16) = SIGT(2)
	EDAT(NUM + 17) = SIGT(3)
	EDAT(NUM + 18) = SIGT(4)
	EDAT(NUM + 19) = SIGT(5)
	EDAT(NUM + 20) = SIGT(6)
	
	IFI = 2 !LAYER 2 (MIDDLE LAYER)
      SGVEC(IPT,8+6*(IFI-1)+1:8+6*(IFI-1)+6) = SIGT(1:6)    !FOR EXTRAPOLATION
      
	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1+20),SIGT,'FIBER6')
	EDAT(NUM + 21) = SIGT(1)
	EDAT(NUM + 22) = SIGT(2)
	EDAT(NUM + 23) = SIGT(3)
	EDAT(NUM + 24) = SIGT(4)
	EDAT(NUM + 25) = SIGT(5)
	EDAT(NUM + 26) = SIGT(6)

	IFI = 3 !LAYER 3 (TOP LAYER)
      SGVEC(IPT,8+6*(IFI-1)+1:8+6*(IFI-1)+6) = SIGT(1:6)    !FOR EXTRAPOLATION
      
	ENDDO
	ENDIF


	IF(MTMOD.EQ.2) THEN
      DO IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES OF SHELL
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))

      SELECTCASE(ISTYP)
      CASE(1)   !4 ANS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(3)   !8 ANS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(4)   !4 QSI
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(11)  !3 QSI
	CALL SHAP2D3(RI,SI,H,HD,NNM)
      CASE(12)  !9 ANS
	CALL SHAP2D9(RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(13)   !SHEAR WALL
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)  
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------

	NUM = (8)*(IPT-1)
	I1 = NWG*(NPOGS(IPT)-1) + 1
	NN = 8

	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1+NN),SIGT,'RESULT')

	EDAT(NUM + 1) = SIGT(1)  !M
	EDAT(NUM + 2) = SIGT(2)
	EDAT(NUM + 3) = SIGT(3)  !B
	EDAT(NUM + 4) = SIGT(4)
	EDAT(NUM + 5) = SIGT(5)
	EDAT(NUM + 6) = SIGT(6)  !S
	EDAT(NUM + 7) = SIGT(7)
	EDAT(NUM + 8) = SIGT(8)

      SGVEC(IPT,1:8) = SIGT(1:8)    !FOR EXTRAPOLATION
      
	ENDDO
	ENDIF


	IF(MTMOD.EQ.4) THEN
      DO IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES OF SHELL
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))

      SELECTCASE(ISTYP)
      CASE(1)   !4 ANS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(3)   !8 ANS
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(4)   !4 QSI
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(11)  !3 QSI
	CALL SHAP2D3(RI,SI,H,HD,NNM)
      CASE(12)  !9 ANS
	CALL SHAP2D9(RI,SI,H,HD,NODEX(1,IEL),NNM)
      CASE(13)   !SHEAR WALL
      CALL SHAP2D (RI,SI,H,HD,NODEX(1,IEL),NNM) 
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------

	NUM = (8+3*2)*(IPT-1)
	I1 = NWG*(NPOGS(IPT)-1) + 1
	NN = 8*NGT

	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1+NN),SIGT,'RESULT')
	EDAT(NUM + 1) = SIGT(1)  !M
	EDAT(NUM + 2) = SIGT(2)
	EDAT(NUM + 3) = SIGT(3)  !B
	EDAT(NUM + 4) = SIGT(4)
	EDAT(NUM + 5) = SIGT(5)
	EDAT(NUM + 6) = SIGT(6)  !S
	EDAT(NUM + 7) = SIGT(7)
	EDAT(NUM + 8) = SIGT(8)

      SGVEC(IPT,1:8) = SIGT(1:8)    !FOR EXTRAPOLATION
      
	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1   ),SIGT,'FIBER3')
	EDAT(NUM + 9)  = SIGT(1)     !Bottom Surface Stresses
	EDAT(NUM + 10) = SIGT(2)
	EDAT(NUM + 11) = SIGT(3)

	IFI = 1 !LAYER 1 (BOTTOM LAYER)
      SGVEC(IPT,8+3*(IFI-1)+1:8+3*(IFI-1)+3) = SIGT(1:3)    !FOR EXTRAPOLATION
      
	NN = 8*(NGT-1)
	CALL SHSRLAX (WOREL(I1),NWG,WOREL(I1+NN),SIGT,'FIBER3')
	EDAT(NUM + 12) = SIGT(1)  !Top Surface Stress
	EDAT(NUM + 13) = SIGT(2)
	EDAT(NUM + 14) = SIGT(3)

	IFI = 2 !LAYER 2 (TOP LAYER)
      SGVEC(IPT,8+3*(IFI-1)+1:8+3*(IFI-1)+3) = SIGT(1:3)    !FOR EXTRAPOLATION
      
	ENDDO
	ENDIF

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES OF SHELL
C     --------------------------------
      EXMAT = MATMUL(TRANSPOSE(EGMAT),EGMAT)
	CALL INVMATRIX(EXMAT,EXMATI,NNM)
	STVEC = MATMUL(EXMATI,MATMUL(TRANSPOSE(EGMAT),SGVEC))
	DO INM = 1,NNM
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC(INM,1:LENGTH) 
	ENDDO
C     --------------------------------

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1) 
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO
          WRITE(NFL1,REC=IEL) AF1(1:N1) 			
C	--------------

      
	ENDDO
	
	DEALLOCATE(STVEC,SGVEC)
	
5000  DEALLOCATE(AF1,EDAT,WOREL)

	DEALLOCATE(EXMAT,EXMATI,EGMAT)

      RETURN
      END
C
C	=====================================================================
C	=====================================================================
C	=====================================================================
       SUBROUTINE SOPOUT(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------
	DIMENSION NPOGS(27),SIG(6)

	DIMENSION NODEX(MEX,1),GPSO(3,27),H(27),HD(3,27)
	
	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)

	ALLOCATABLE EGMAT(:,:),EXMAT(:,:),EXMATI(:,:),SGVEC(:,:),STVEC(:,:)
	
	
	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

      	
	IF(ISTYP.EQ.4) THEN
	 CALL SSOPOUT2(KEG,NODEX,MEX) !FOR RESULTANT STRESS
       CALL SSOPOUT3(KEG,NODEX,MEX) !FOR STRESS
	GO TO 100
      ENDIF

      SELECTCASE(ISTYP)
      CASE(6,8)   !8 NODE HEXA
	NPOGS(1:8) = [7,3,1,5,8,4,2,6]
	 GPSO(1:3,1) = [-0.57735026918963,-0.57735026918963,-0.57735026918963]
	 GPSO(1:3,2) = [-0.57735026918963,-0.57735026918963,+0.57735026918963]
	 GPSO(1:3,3) = [-0.57735026918963,+0.57735026918963,-0.57735026918963]
	 GPSO(1:3,4) = [-0.57735026918963,+0.57735026918963,+0.57735026918963]
	 GPSO(1:3,5) = [+0.57735026918963,-0.57735026918963,-0.57735026918963]
	 GPSO(1:3,6) = [+0.57735026918963,-0.57735026918963,+0.57735026918963]
	 GPSO(1:3,7) = [+0.57735026918963,+0.57735026918963,-0.57735026918963]
	 GPSO(1:3,8) = [+0.57735026918963,+0.57735026918963,+0.57735026918963]
      CASE(13)    !3 NODE AND 10 NODE TETRA
	NPOGS(1:4) = [2,1,4,3]
	 IND = 1 !FOR SOLID ELEM
	 DO IPT = 1,NPT
	  CALL GAUSST (GPSO(1,IPT),GPSO(2,IPT),GPSO(3,IPT),W,IPT,NPT,IND)
	 ENDDO
	 
	CASE DEFAULT
	 RETURN
	ENDSELECT
	
	
	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))

C     -------------------------------
C     -------------------------------
	ALLOCATE(EGMAT(NPT,NNM),EXMAT(NNM,NNM),EXMATI(NNM,NNM))

	ALLOCATE(SGVEC(NPT,LENGTH),STVEC(NNM,LENGTH))
C     ---------------------------------


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED') ! Call WOREL 

C     ---------------
      DO IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES 
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))
      TI = GPSO(3,NPOGS(IPT))

      SELECTCASE(ISTYP)
      
       
      CASE(6,8)   !8 NODE HEXA
      CALL SHAP3D (RI,SI,TI,H,HD,NODEX(1,IEL),NNM)
      CASE(13)    !3 NODE AND 10 NODE TETRA
      CALL SHAP3DT(RI,SI,TI,H,HD,NNM)
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------      
      
	I1 = NWG*(NPOGS(IPT)-1)
      DO K=1,6
	SIG(K) = WOREL(I1+K)
	ENDDO
	CALL POSVMS(SIG,VMISE)

      SELECTCASE(ISTYP)
      
      CASE(6,8,13)   !8 NODE HEXA
	NUM = LENGTH*(IPT-1)
	EDAT(NUM + 1) = SIG(1)  
	EDAT(NUM + 2) = SIG(2)  
	EDAT(NUM + 3) = SIG(3)  
	EDAT(NUM + 4) = SIG(4)  
	EDAT(NUM + 5) = SIG(5)  
	EDAT(NUM + 6) = SIG(6)  
	EDAT(NUM + 7) = VMISE
	
      SGVEC(IPT,1:6) = SIG(1:6)    !FOR EXTRAPOLATION
      SGVEC(IPT,7  ) = VMISE       !FOR EXTRAPOLATION

	ENDSELECT	      
	ENDDO
C     ---------------

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
      EXMAT = MATMUL(TRANSPOSE(EGMAT),EGMAT)
	CALL INVMATRIX(EXMAT,EXMATI,NNM)
	STVEC = MATMUL(EXMATI,MATMUL(TRANSPOSE(EGMAT),SGVEC))
	DO INM = 1,NNM
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC(INM,1:LENGTH) 
	ENDDO
C     --------------------------------

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1) 
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1) 		
C	--------------
	
	ENDDO

	
	DEALLOCATE(AF1,EDAT,WOREL)
	
	DEALLOCATE(EXMAT,EXMATI,STVEC,EGMAT,SGVEC)

100   RETURN
      END


C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE SSOPOUT2(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------

      COMMON /GAUS/ GLOC(10,10),GWT(10,10),NGR,NGS,NGT
      
      COMMON /HOOK/  A1,B1,C1,D1,A2,B2,C2,D2,BM,YM,PR,TH,YLD,ISR,IST
 
      COMMON A(9000000),IA(9000000)
      
      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF      

C     SAVE LOCAL DISPLACEMENT    
      COMMON /NEWDATA/ SDISL(1000000,24)
C    SAVE NUMBER(NMX) FOR LVNUM ACCORDING TO ELEMENT  
      COMMON /SLVNUM/ INMX(1000000,1)       	
      
	DIMENSION NPOGS(27),SIG(9),H1(27),H2(27),P(2,4) 

	DIMENSION NODEX(MEX,1),GPSO(2,27)
	
	DIMENSION NPM(10),NPI(10)
		
CB    DISPLACEMENT IN MID-SURFACE
	DIMENSION DISPM(4,3)

CB    FOR RATIO MATRIX
      DIMENSION RATIOM(4,9)	

CB    FOR UPPER & LOWER STRESS ON NODAL
      DIMENSION STRESSNU(4,9),STRESSNL(4,9)    
      DIMENSION STRESSNUN(4,9),STRESSNLN(4,9) !MATRIX FOR CORRESPONDING WITH THE ORDER OF CONNECTIVITY
      DIMENSION SIG_SAVE(9)
      DIMENSION ILVNUM(8)      
      DIMENSION IM_MAT(6) ! MEMBRANE & BENDING NUMBER MATRIX
      
      
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)      
      
	ALLOCATABLE EGMAT1(:,:),EXMAT1(:,:),EXMATI1(:,:),SGVEC1(:,:),STVEC1(:,:),STVEC1_DUM(:,:)
	ALLOCATABLE EGMAT2(:,:),EXMAT2(:,:),EXMATI2(:,:),SGVEC2(:,:),STVEC2(:,:),STVEC2_SAVE(:,:)
	
CB    FOR CALLING DISPLACEMENT		
	ALLOCATABLE DISPDAT(:),DISPN(:,:)
	
CB    FOR CALLING MATRIX FOR IMAX MATRIX TO DETECT THE THIN DIRECTION 
CB      ALLOCATABLE INMX(:,:)
CB      ALLOCATABLE ILVNUM(:)
      ALLOCATABLE ILVNUM2(:,:)
      
CB    FOR CONNECTIVITY MATRIX 
	ALLOCATABLE LM(:,:)   
CB    FOR SAVING DISPLACEMENT UPPER & LOWER RESPECTIVELY
      ALLOCATABLE DISPU(:,:),DISPL(:,:)
      
CB    FOR CALLING MATRIX FOR LOCAL DISPLACEMENT
CDIS      ALLOCATABLE SDISL(:,:)
	
	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0)!
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !
	CALL INTFILL('OGRF',NFL5 ,15,IEG,0) !FOR SOLID-SHELL STRESS OUTPUT
		

CBJ 	NPOGS(1:4) = [1,3,4,2] !Completed


 	NPOGS(1:4) = [1,2,3,4]
      
      

 
CBJ	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963] !Completed
CBJ	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
CBJ	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
CBJ	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]	 

	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963] !Completed
	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]	
      

C     DATA FOR ONLY SOLID-SHELL
	 NNM1 = 4
	 NNM2 = 8
	 
	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))      
	
            
C     -------------------------------
C     -------------------------------
	ALLOCATE(EGMAT1(NPT,NNM1),EXMAT1(NNM1,NNM1),EXMATI1(NNM1,NNM1))
	ALLOCATE(EGMAT2(NPT,NNM2),EXMAT2(NNM2,NNM2),EXMATI2(NNM2,NNM2))

	ALLOCATE(SGVEC1(NPT,LENGTH),STVEC1(NNM1,LENGTH),STVEC1_DUM(NNM1,LENGTH))
	ALLOCATE(SGVEC2(NPT,LENGTH),STVEC2(NNM2,LENGTH),STVEC2_SAVE(NNM2,LENGTH))

C     ------------------------------------------
CB    FOR CALLING DISPLACEMENT	
	CALL LOCATN('ONDS',KDISP,NOUT2,NSN,2)	
      
      NSN2 = NSN/2 
          
      ALLOCATE(DISPDAT(NOUT2),DISPN(NSN,3))
C     ------------------------------------------
CB    FOR CALLING MATRIX FOR DETECTING THE THIN DIRECTION 
CB      ALLOCATE(INMX(NELE,1))
CB      ALLOCATE(ILVNUM(8))
      ALLOCATE(ILVNUM2(NELE,8))
      
CCB      REWIND(NFL5)
CCB      READ(NFL5) INMX

CB    FOR CALLING MATRIX FOR LOCAL DISPLACEMENT
CDIS      ALLOCATE(SDISL(NELE,24))       
      
CDIS      REWIND(NFL5)
CDIS      READ(NFL5) SDISL
C     ---------------------------------------------------

CB    FOR CONNECTIVITY MATRIX 
	ALLOCATE(LM(NELE,8))

	      
CB    FOR SAVING DISPLACEMENT UPPER & LOWER RESPECTIVELY (ONE ELEMENT)
      ALLOCATE(DISPU(4,3),DISPL(4,3)) 
           
C     ---------------------------------------------------

CC    INITIALIZATION
      EDAT = 0.0
      
      EGMAT1 = 0.0
      EXMAT1 = 0.0
      EXMATI1 = 0.0
      SGVEC1 = 0.0
      STVEC1 = 0.0
      
      EGMAT2 = 0.0
      EXMAT2 = 0.0
      EXMATI2 = 0.0
      SGVEC2 = 0.0
      STVEC2 = 0.0
      
      SIG = 0.0
      DISPN = 0.0
      
      DO ILV = 1,NELE
CCV        ILVNUM2(ILV,1:8) = [1,3,5,7,2,4,6,8]      
        ILVNUM2(ILV,1:8) = [1,4,8,5,2,3,7,6]      
      ENDDO
      
      DO 800 IEL=1,NELE

CB    FOR CALLING MATRIX FOR DETECTING THE THIN DIRECTION 

      NMX = INMX(IEL,1)
      
      IF(NMX.EQ.1) THEN
	ILVNUM(1) = 1
	ILVNUM(2) = 4
	ILVNUM(3) = 8
	ILVNUM(4) = 5
	ILVNUM(5) = 2
	ILVNUM(6) = 3
	ILVNUM(7) = 7
	ILVNUM(8) = 6
	ELSEIF(NMX.EQ.2) THEN
	ILVNUM(1) = 1
	ILVNUM(2) = 5
	ILVNUM(3) = 6
	ILVNUM(4) = 2
	ILVNUM(5) = 4
	ILVNUM(6) = 8
	ILVNUM(7) = 7
	ILVNUM(8) = 3
	ELSEIF(NMX.EQ.3) THEN
	ILVNUM(1) = 1
	ILVNUM(2) = 2
	ILVNUM(3) = 3
	ILVNUM(4) = 4
	ILVNUM(5) = 5
	ILVNUM(6) = 6
	ILVNUM(7) = 7
	ILVNUM(8) = 8
	ENDIF


	CALL ADREWT(KEG,IEL,WOREL,'RED') ! Call WOREL      

CB      IF(IEL.EQ.120) THEN
CB      WRITE(*,*) "WOREL"
CB      WRITE(*,*) WOREL 
CB      ENDIF   
C     ---------------

C     ----------------------
C     LOOP OVER GAUSS POINTS
C     ----------------------

C     ----------------------   
C     LOOP OVER GAUSS POINTS
C     ----------------------
CPT      MGR=2
CPT	MGS=2
CPT      IPT = 0
CPT      DO 900  IGR=1,MGR
CPT        RI = GLOC(IGR,MGR)
CPT      DO 900  IGS=1,MGS
CPT        SI = GLOC(IGS,MGS)
CPT        IPT = IPT+1
      
      DO 900 IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES 
C     --------------------------------
            RI = GPSO(1,NPOGS(IPT))
            SI = GPSO(2,NPOGS(IPT))    
           
C     ------------------------------------
C     SHAPE FUNCTIONS (H), DERIVATIVES (P)
C     ------------------------------------	      

CB          CALL SHAP8NEWP1(RI,SI,H1)	
      CALL SHAP8NEW(RI,SI,H1,P)
         

          EGMAT1(IPT,1:NNM1) = H1(1:NNM1)
          EGMAT2(IPT,1:NNM2) = H2(1:NNM2)
C     --------------------------------      
          
	    !!I1 = NWG*(NPOGS(IPT)-1)          
          !!DO K=1,9
	    !!SIG(K) = WOREL(I1+K)
          !!ENDDO
          
          I1 = NWG*(NPOGS(IPT)-1) + 1	
          !CALL SHSRLAX_SHL (WOREL(I1),NWG,WOREL(I1),SIG,'FIBER6')   
          CALL SHSRLAX_SHL (WOREL(I1),NWG,WOREL(I1),SIG,'RESULT')                                                 

	    CALL POSVMS(SIG,VMISE)
          
          DO J = 1,9
                STG1 = SIG(J)
                STG2 = ABS(STG1)

                IF(STG2.LT.1e-9) THEN
                 SIG(J) = 0.0
                ENDIF
           ENDDO
          
          
          NUM = LENGTH*(IPT-1)
          
	    EDAT(NUM + 1) = SIG(1)  
	    EDAT(NUM + 2) = SIG(2)  
	    EDAT(NUM + 3) = SIG(3)  
	    EDAT(NUM + 4) = SIG(4)  
	    EDAT(NUM + 5) = SIG(5)  
	    EDAT(NUM + 6) = SIG(6)
	    EDAT(NUM + 7) = SIG(7)
	    EDAT(NUM + 8) = SIG(8)
	    EDAT(NUM + 9) = SIG(9)
	    EDAT(NUM +10) = VMISE
    	    
    	
	    SGVEC1(IPT,1:9) = SIG(1:9)    !FOR EXTRAPOLATION
          SGVEC1(IPT,10 ) = VMISE       !FOR EXTRAPOLATION
            
900	ENDDO
C     ----------------------
C     END OVER GAUSS POINTS
C     ----------------------

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
C----- 1. INTERPOLATE TO 4 NODES 
      EXMAT1 = MATMUL(TRANSPOSE(EGMAT1),EGMAT1)
	CALL INVMATRIX(EXMAT1,EXMATI1,NNM1)
	STVEC1 = MATMUL(EXMATI1,MATMUL(TRANSPOSE(EGMAT1),SGVEC1))
      
      !TO CONTROL SHEAR(ST) ---------
      !!STVEC1_DUM = STVEC1
      
      !!STVEC1(1,9) = STVEC1_DUM(3,9)
      !!STVEC1(2,9) = STVEC1_DUM(4,9)
      !!STVEC1(3,9) = STVEC1_DUM(1,9)
      !!STVEC1(4,9) = STVEC1_DUM(2,9)
      !-----------------------------
	
C----- 2. INTERPOLATE WITH THICKNESS DIRECTION

CB    EXMAT2 = MATMUL(TRANSPOSE(EGMAT2),EGMAT2)
CB	CALL INVMATRIX(EXMAT2,EXMATI2,NNM2)
CB	STVEC2 = MATMUL(EXMATI2,MATMUL(TRANSPOSE(EGMAT2),STVEC1))	


C----- 2-1. CALL DISPLACEMENT OF EACH NODES
      
CDIS	DO ISN = 1,NSN
CDIS	    DO I = 1,NOUT2
CDIS	      CALL RELFILL('ONDS',DISPDAT(I),I,ISN,0)  
CDIS	    ENDDO
CDIS          DISPN(ISN,1:3) = DISPDAT(1:3)      
CDIS	ENDDO
	

C----- 2-2. CALL MATRIX FOR DETECTING THE THIN DIRECTION 
      
C           ILVNUM(IEL,8)

C----- 2-3. CALL MATRIX FOR CONNECTIVITY
            
CDIS        LM(IEL,1:8) = IA(LCN+(24*(IEL-1)):LCN+(24*(IEL-1))+7) 
        
      DO JEL = 1,NELE
        LM(JEL,1:8) = IA(LCN+(24*(JEL-1)):LCN+(24*(JEL-1))+7) 
	  DO JSN = 1,8
	      IM = LM(JEL,JSN) 
	      DISPN(IM,1:3) = SDISL(JEL,1+(3*(JSN-1)):3+(3*(JSN-1)))
CDIS	      DISPN(IM,1:3) = SDISL(IEL,1:3)
CDIS            DISPN(IM,1) = SDISL(JEL,1+3*(JSN-1))
CDIS            DISPN(IM,2) = SDISL(JEL,3+3*(JSN-1))
CDIS            DISPN(IM,3) = SDISL(JEL,2+3*(JSN-1))
	  ENDDO
      ENDDO

C------2-4. CALCULATE DISPLACEMENT IN MID-SURFACE
     
      DO I=1,3
	DO J=1,4
	    JJ  = ILVNUM(J)
	    JJJ = ILVNUM(J+4)
CNUM          JJ  = ILVNUM2(IEL,J)
CNUM          JJJ = ILVNUM2(IEL,J+4)
CNUM1          JJ = J
CNUM1          JJJ = J+4
	    IM1 = LM(IEL,JJ)
	    IM2 = LM(IEL,JJJ)
          DISPM(J,I)=(DISPN(IM1,I)+DISPN(IM2,I))/2. !DISPLACEMENT IN MID-SURFACE            
          
          DISPU(J,I) = DISPN(IM1,I)
          DISPL(J,I) = DISPN(IM2,I)
          
	ENDDO
	ENDDO

C------2-5. CALCULATE RATIO OF STRESS/DISPLACEMENT
      RATIOM = 0.0
      
      DO 1000 IR = 1,4    
      
      RA1 = DISPM(IR,1) !X = R
      RA2 = DISPM(IR,2) !Y = S
      RA3 = DISPM(IR,3) !Z = T
      

      
      ABRA1 = ABS(RA1)
      ABRA2 = ABS(RA2)
      ABRA3 = ABS(RA3)


C ----- EXPLANATION FOR RATIO MATIX -----      
C     FOR MEMBRANE R,S,RS      
C        RATIOM(IR,1) = STVEC1(IR,1)/RA1          
C        RATIOM(IR,2) = STVEC1(IR,2)/RA2
C        RATIOM(IR,3) = STVEC1(IR,3)/RA3
C     FOR BENDING RR,SS,RS              
C        RATIOM(IR,4) = STVEC1(IR,4)/RA1
C        RATIOM(IR,5) = STVEC1(IR,5)/RA2
C        RATIOM(IR,6) = STVEC1(IR,6)/RA3
C     FOR TRANSVERSE NORMAL TT              
C        RATIOM(IR,7) = STVEC1(IR,7)/RA3
C     FOR TRANSVERSE SHEAR RT,ST
C        RATIOM(IR,8) = STVEC1(IR,8)/RA1
C        RATIOM(IR,9) = STVEC1(IR,9)/RA2      
C ----------------------------------------      
      IF(ABRA1.EQ.0) THEN
C       FOR MEMBRANE R
         RATIOM(IR,1) = 1  
C       FOR MEMBRANE S 
         RATIOM(IR,2) = 1  
C       FOR MEMBRANE RS        
         RATIOM(IR,6) = 1    
      ELSE
         RATIOM(IR,1) = STVEC1(IR,1)/RA1 !R
         RATIOM(IR,2) = STVEC1(IR,2)/RA1 !R
         RATIOM(IR,6) = STVEC1(IR,6)/RA1 !R
       ENDIF

      IF(ABRA2.EQ.0) THEN 
C       FOR BENDING RR
         RATIOM(IR,3) = 1                      
C       FOR BENDING SS
         RATIOM(IR,4) = 1
C       FOR BENDING RS
         RATIOM(IR,5) = 1
      ELSE
         RATIOM(IR,3) = STVEC1(IR,3)/RA3 !T
         RATIOM(IR,4) = STVEC1(IR,4)/RA3 !T 
         RATIOM(IR,5) = STVEC1(IR,5)/RA3 !T      
      ENDIF

      IF(ABRA3.EQ.0) THEN
   
CR      FOR TRANSVERSE NORMAL TT  
         RATIOM(IR,7) = 1       
CR      FOR TRANSVERSE SHEAR RT
         RATIOM(IR,8) = 1   
CR      FOR TRANSVERSE SHEAR ST
         RATIOM(IR,9) = 1                
      ELSE       
         RATIOM(IR,7) = STVEC1(IR,7)/RA3 !T
         RATIOM(IR,8) = STVEC1(IR,8)/RA3 !T
         RATIOM(IR,9) = STVEC1(IR,9)/RA3 !T
      ENDIF
          
    
1000    ENDDO

C------2-6. CALCULATE UPPER/LOWER DISP WITH RATIO
      IM_MAT(1:6) = [1,2,9,3,4,5]      
      DO IS = 1,4
       DO IMM = 1,3              
       DU = DISPU(IS,IMM)
       DL = DISPL(IS,IMM)       
       IM = IM_MAT(IMM) 
       IB = IM_MAT(IMM+3) 
          IF(DU.EQ.0.OR.RATIOM(IS,IM).EQ.1) THEN
            STRESSNU(IS,IM) = STVEC1(IS,IM)
            STRESSNU(IS,IB) = STVEC1(IS,IB)
          ELSE        
C     FOR MEMBRANE R,S,RS
            !!STRESSNU(IS,IM) = RATIOM(IS,IM)*DISPU(IS,1) !R
            STRESSNU(IS,IM) = STVEC1(IS,IM)
C     FOR BENDING RR,SS,RS
            STRESSNU(IS,IB) = RATIOM(IS,IB)*DISPU(IS,3) !T          
CR            STRESSNU(IS,IM+3) = RATIOM(IS,IM+3)*DISPU(IS,IM)
          ENDIF
      
          IF(DL.EQ.0.OR.RATIOM(IS,IM).EQ.1) THEN
            STRESSNL(IS,IM) = STVEC1(IS,IM)
            STRESSNL(IS,IB) = STVEC1(IS,IB)
          ELSE        
C     FOR MEMBRANE R,S,RS
            !!STRESSNL(IS,IM) = RATIOM(IS,IM)*DISPL(IS,1) !R       
            STRESSNL(IS,IM) = STVEC1(IS,IM) !R 
C     FOR BENDING RR,SS,RS
            STRESSNL(IS,IB) = RATIOM(IS,IB)*DISPL(IS,3) !T           
CR          STRESSNL(IS,IM+3) = RATIOM(IS,IM+3)*DISPL(IS,IM)       
          ENDIF
       ENDDO
      ENDDO

      
C     FOR TRANSVERSE NORMAL TT
      DO IS = 1,4  
       DU = DISPU(IS,IM)
       DL = DISPL(IS,IM)
      IF(DU.EQ.0.OR.RATIOM(IS,7).EQ.1) THEN
        STRESSNU(IS,7) = STVEC1(IS,7)     
      ELSE
        STRESSNU(IS,7) = RATIOM(IS,7)*DISPU(IS,3) !T  
      ENDIF

      IF(DL.EQ.0.OR.RATIOM(IS,7).EQ.1) THEN  
        STRESSNL(IS,7) = STVEC1(IS,7)
      ELSE
        STRESSNL(IS,7) = RATIOM(IS,7)*DISPL(IS,3) !T  
      ENDIF
        
      ENDDO

C     FOR TRANSVERSE SHEAR RT,ST
      DO IS = 1,4
       !!DO IM = 1,2
        DU = DISPU(IS,IM)
        DL = DISPL(IS,IM)
        
        !!IF(DU.EQ.0) THEN
        !!STRESSNU(IS,IM+7) = STVEC1(IS,IM+7)
        !!ELSE
        STRESSNU(IS,6) = STVEC1(IS,6)!RATIOM(IS,IM+7)*DISPU(IS,3) !T
        !!ENDIF
        STRESSNU(IS,8) = STVEC1(IS,8)
        !!IF(DL.EQ.0) THEN
        !!STRESSNL(IS,IM+7) = STVEC1(IS,IM+7)
        !!ELSE
        STRESSNL(IS,6) = STVEC1(IS,6)!RATIOM(IS,IM+7)*DISPL(IS,3) !T
        STRESSNL(IS,8) = STVEC1(IS,8)
        !!ENDIF
        
       !!ENDDO
      ENDDO
            
C------2-7. CHANGE THE ORDER OF STRESS MATRIX TO CORRESPOND WITH ORDER OF CONNECTIVITY

CNUM       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
CNUM       STRESSNUN(2,1:9) = STRESSNL(2,1:9)
CNUM       STRESSNUN(3,1:9) = STRESSNU(4,1:9)
CNUM       STRESSNUN(4,1:9) = STRESSNL(3,1:9)
    
CNUM       STRESSNLN(1,1:9) = STRESSNL(1,1:9)
CNUM       STRESSNLN(2,1:9) = STRESSNU(2,1:9)
CNUM       STRESSNLN(3,1:9) = STRESSNL(4,1:9)
CNUM       STRESSNLN(4,1:9) = STRESSNU(3,1:9)
       
      IF(NMX.EQ.1) THEN
       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
       STRESSNUN(2,1:9) = STRESSNL(2,1:9)
       STRESSNUN(3,1:9) = STRESSNU(4,1:9)
       STRESSNUN(4,1:9) = STRESSNL(3,1:9)
       
    
       STRESSNLN(1,1:9) = STRESSNL(1,1:9)
       STRESSNLN(2,1:9) = STRESSNU(2,1:9)
       STRESSNLN(3,1:9) = STRESSNL(4,1:9)
       STRESSNLN(4,1:9) = STRESSNU(3,1:9)       
       

       DO I = 1,4
        DO J = 1,9
        
            STU1 = STRESSNUN(I,J)
            STL1 = STRESSNLN(I,J) 
            
            STU2 = ABS(STU1)
            STL2 = ABS(STL1)
            
            IF(STU2.LT.1e-10) THEN
                STRESSNUN(I,J) = 0.0
            ENDIF
            
            IF(STL2.LT.1e-10) THEN
                STRESSNLN(I,J) = 0.0
            ENDIF        
            
        ENDDO
       ENDDO

C------2-8. STORE THE UPPER & LOWER STRESSES INTO STVEC2 MATRIX

       DO I = 1,4
         STVEC2(2*I-1,1:9) = STRESSNUN(I,1:9)
         STVEC2(2*I,1:9) = STRESSNLN(I,1:9)
       ENDDO
      
      ELSEIF(NMX.EQ.2) THEN
     
       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
       STRESSNUN(2,1:9) = STRESSNL(4,1:9)
       STRESSNUN(3,1:9) = STRESSNU(2,1:9)
       STRESSNUN(4,1:9) = STRESSNL(3,1:9)
    
       STRESSNLN(1,1:9) = STRESSNU(4,1:9)
       STRESSNLN(2,1:9) = STRESSNL(1,1:9)
       STRESSNLN(3,1:9) = STRESSNU(3,1:9)
       STRESSNLN(4,1:9) = STRESSNL(2,1:9)      


       DO I = 1,4
        DO J = 1,9
        
            STU1 = STRESSNUN(I,J)
            STL1 = STRESSNLN(I,J) 
            
            STU2 = ABS(STU1)
            STL2 = ABS(STL1)
            
            IF(STU2.LT.1e-10) THEN
                STRESSNUN(I,J) = 0.0
            ENDIF
            
            IF(STL2.LT.1e-10) THEN
                STRESSNLN(I,J) = 0.0
            ENDIF        
            
        ENDDO
       ENDDO
       
C------2-8. STORE THE UPPER & LOWER STRESSES INTO STVEC2 MATRIX

       DO I = 1,4
         STVEC2(2*I-1,1:9) = STRESSNUN(I,1:9)
         STVEC2(2*I,1:9) = STRESSNLN(I,1:9)
       ENDDO
       
       ELSEIF(NMX.EQ.3) THEN
     
       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
       STRESSNUN(2,1:9) = STRESSNU(2,1:9)
       STRESSNUN(3,1:9) = STRESSNU(3,1:9)
       STRESSNUN(4,1:9) = STRESSNU(4,1:9)
    
       STRESSNLN(1,1:9) = STRESSNL(1,1:9)
       STRESSNLN(2,1:9) = STRESSNL(2,1:9)
       STRESSNLN(3,1:9) = STRESSNL(3,1:9)
       STRESSNLN(4,1:9) = STRESSNL(4,1:9)       


       DO I = 1,4
        DO J = 1,9
        
            STU1 = STRESSNUN(I,J)
            STL1 = STRESSNLN(I,J) 
            
            STU2 = ABS(STU1)
            STL2 = ABS(STL1)
            
            IF(STU2.LT.1e-10) THEN
                STRESSNUN(I,J) = 0.0
            ENDIF
            
            IF(STL2.LT.1e-10) THEN
                STRESSNLN(I,J) = 0.0
            ENDIF        
            
        ENDDO
       ENDDO

C------2-8. STORE THE UPPER & LOWER STRESSES INTO STVEC2 MATRIX

      DO I = 1,4
        STVEC2(I,1:9) = STRESSNUN(I,1:9)
        STVEC2(I+4,1:9) = STRESSNLN(I,1:9)
      ENDDO
      
       ENDIF   
            
	DO INM = 1,NNM2 
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC2(INM,1:LENGTH) 
	ENDDO
	
	

          READ(NFL1,REC=IEL) AF1(1:N1) 
          
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1) 		
C	--------------
	
800	ENDDO

	
	DEALLOCATE(AF1,EDAT,WOREL)      
	
	DEALLOCATE(EXMAT1,EXMATI1,STVEC1,EGMAT1,SGVEC1,STVEC1_DUM)
	DEALLOCATE(EXMAT2,EXMATI2,STVEC2,EGMAT2,SGVEC2,STVEC2_SAVE)
	
	DEALLOCATE(DISPDAT,DISPN)
CB	DEALLOCATE(INMX)
CB	DEALLOCATE(ILVNUM)
	DEALLOCATE(ILVNUM2)
	DEALLOCATE(LM)
      DEALLOCATE(DISPU,DISPL)
CDIS      DEALLOCATE(SDISL)

      RETURN
      END

C	=================================================================
C	=================================================================
C	================================================================= 
      SUBROUTINE SSOPOUT3(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------

      COMMON /GAUS/ GLOC(10,10),GWT(10,10),NGR,NGS,NGT
      
      COMMON /HOOK/  A1,B1,C1,D1,A2,B2,C2,D2,BM,YM,PR,TH,YLD,ISR,IST
 
      COMMON A(9000000),IA(9000000)
      
      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF      

C     SAVE LOCAL DISPLACEMENT    
      COMMON /NEWDATA/ SDISL(1000000,24)
C    SAVE NUMBER(NMX) FOR LVNUM ACCORDING TO ELEMENT  
      COMMON /SLVNUM/ INMX(1000000,1)  
      
CB    THE THICKNESS      
      COMMON /THICKM/THKM(1000000)      
      
	DIMENSION NPOGS(27),SIG(9),H1(27),H2(27),P(2,4) 

	DIMENSION NODEX(MEX,1),GPSO(2,27)
	
	DIMENSION NPM(10),NPI(10)
		
CB    DISPLACEMENT IN MID-SURFACE
	DIMENSION DISPM(4,3)

CB    FOR RATIO MATRIX
      DIMENSION RATIOM(4,9)	

CB    FOR UPPER & LOWER STRESS ON NODAL
      DIMENSION STRESSNU(4,9),STRESSNL(4,9)    
      DIMENSION STRESSNUN(4,9),STRESSNLN(4,9) !MATRIX FOR CORRESPONDING WITH THE ORDER OF CONNECTIVITY
      DIMENSION SIG_SAVE(9)
      DIMENSION ILVNUM(8)      	
      
	ALLOCATABLE AF2(:),EDAT(:),WOREL2(:)      
      
	ALLOCATABLE EGMAT1(:,:),EXMAT1(:,:),EXMATI1(:,:),SGVEC1(:,:),STVEC1(:,:),STVEC1_DUM(:,:)
	ALLOCATABLE EGMAT2(:,:),EXMAT2(:,:),EXMATI2(:,:),SGVEC2(:,:),STVEC2(:,:),SIG_FIBER(:),STVEC2_FIBER(:,:)
	
CB    FOR CALLING DISPLACEMENT		
	ALLOCATABLE DISPDAT(:),DISPN(:,:)
	
CB    FOR CALLING MATRIX FOR IMAX MATRIX TO DETECT THE THIN DIRECTION 
CB      ALLOCATABLE INMX(:,:)
CB      ALLOCATABLE ILVNUM(:)
      ALLOCATABLE ILVNUM2(:,:)
      
CB    FOR CONNECTIVITY MATRIX 
	ALLOCATABLE LM(:,:)   
CB    FOR SAVING DISPLACEMENT UPPER & LOWER RESPECTIVELY
      ALLOCATABLE DISPU(:,:),DISPL(:,:)
      
CB    FOR CALLING MATRIX FOR LOCAL DISPLACEMENT
CDIS      ALLOCATABLE SDISL(:,:)
	
	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0)!
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !
	CALL INTFILL('OGRF',NFL5 ,15,IEG,0) !FOR SOLID-SHELL STRESS OUTPUT
		

CBJ 	NPOGS(1:4) = [1,3,4,2] !Completed


 	NPOGS(1:4) = [1,2,3,4]

 
CBJ	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963] !Completed
CBJ	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
CBJ	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
CBJ	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]	 

	 GPSO(1:2,1) = [-0.57735026918963,-0.57735026918963] !Completed
	 GPSO(1:2,2) = [-0.57735026918963,+0.57735026918963]
	 GPSO(1:2,3) = [+0.57735026918963,-0.57735026918963]
	 GPSO(1:2,4) = [+0.57735026918963,+0.57735026918963]	
      

C     DATA FOR ONLY SOLID-SHELL
	 NNM1 = 4
	 NNM2 = 8
	 
	ALLOCATE(AF2(N1),EDAT(NOUT),WOREL2(NWA))      
	
            
C     -------------------------------
C     -------------------------------
	ALLOCATE(EGMAT1(NPT,NNM1),EXMAT1(NNM1,NNM1),EXMATI1(NNM1,NNM1))
	ALLOCATE(EGMAT2(NPT,NNM2),EXMAT2(NNM2,NNM2),EXMATI2(NNM2,NNM2))

	ALLOCATE(SGVEC1(NPT,LENGTH),STVEC1(NNM1,LENGTH),STVEC1_DUM(NNM1,LENGTH))
	ALLOCATE(SGVEC2(NPT,LENGTH),STVEC2(NNM2,LENGTH),SIG_FIBER(9),STVEC2_FIBER(NNM2,LENGTH))

C     ------------------------------------------
CB    FOR CALLING DISPLACEMENT	
	CALL LOCATN('ONDS',KDISP,NOUT2,NSN,2)	
      
      NSN2 = NSN/2 
          
      ALLOCATE(DISPDAT(NOUT2),DISPN(NSN,3))
C     ------------------------------------------
CB    FOR CALLING MATRIX FOR DETECTING THE THIN DIRECTION 
CB      ALLOCATE(INMX(NELE,1))
CB      ALLOCATE(ILVNUM(8))
      ALLOCATE(ILVNUM2(NELE,8))
      
CCB      REWIND(NFL5)
CCB      READ(NFL5) INMX

CB    FOR CALLING MATRIX FOR LOCAL DISPLACEMENT
CDIS      ALLOCATE(SDISL(NELE,24))       
      
CDIS      REWIND(NFL5)
CDIS      READ(NFL5) SDISL
C     ---------------------------------------------------

CB    FOR CONNECTIVITY MATRIX 
	ALLOCATE(LM(NELE,8))

	      
CB    FOR SAVING DISPLACEMENT UPPER & LOWER RESPECTIVELY (ONE ELEMENT)
      ALLOCATE(DISPU(4,3),DISPL(4,3)) 
           
C     ---------------------------------------------------

CC    INITIALIZATION
      EDAT = 0.0
      
      EGMAT1 = 0.0
      EXMAT1 = 0.0
      EXMATI1 = 0.0
      SGVEC1 = 0.0
      STVEC1 = 0.0
      
      EGMAT2 = 0.0
      EXMAT2 = 0.0
      EXMATI2 = 0.0
      SGVEC2 = 0.0
      STVEC2 = 0.0
      
      SIG = 0.0
      DISPN = 0.0
      
      DO ILV = 1,NELE
CCV        ILVNUM2(ILV,1:8) = [1,3,5,7,2,4,6,8]      
        ILVNUM2(ILV,1:8) = [1,4,8,5,2,3,7,6]      
      ENDDO
      
      DO 800 IEL=1,NELE
      
          
C     THICKNESS          
      THK = THKM(IEL)
CB    FOR CALLING MATRIX FOR DETECTING THE THIN DIRECTION 

      NMX = INMX(IEL,1)
      
      IF(NMX.EQ.1) THEN
	ILVNUM(1) = 1
	ILVNUM(2) = 4
	ILVNUM(3) = 8
	ILVNUM(4) = 5
	ILVNUM(5) = 2
	ILVNUM(6) = 3
	ILVNUM(7) = 7
	ILVNUM(8) = 6
	ELSEIF(NMX.EQ.2) THEN
	ILVNUM(1) = 1
	ILVNUM(2) = 5
	ILVNUM(3) = 6
	ILVNUM(4) = 2
	ILVNUM(5) = 4
	ILVNUM(6) = 8
	ILVNUM(7) = 7
	ILVNUM(8) = 3
	ELSEIF(NMX.EQ.3) THEN
	ILVNUM(1) = 1
	ILVNUM(2) = 2
	ILVNUM(3) = 3
	ILVNUM(4) = 4
	ILVNUM(5) = 5
	ILVNUM(6) = 6
	ILVNUM(7) = 7
	ILVNUM(8) = 8
	ENDIF


	CALL ADREWTN(KEG,IEL,WOREL2,'RED') ! Call WOREL      

CB      IF(IEL.EQ.120) THEN
CB      WRITE(*,*) "WOREL"
CB      WRITE(*,*) WOREL 
CB      ENDIF   
C     ---------------


C     ----------------------   
C     LOOP OVER GAUSS POINTS
C     ----------------------
CPT      MGR=2
CPT	MGS=2
CPT      IPT = 0
CPT      DO 900  IGR=1,MGR
CPT        RI = GLOC(IGR,MGR)
CPT      DO 900  IGS=1,MGS
CPT        SI = GLOC(IGS,MGS)
CPT        IPT = IPT+1
      
      DO 900 IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES 
C     --------------------------------
            RI = GPSO(1,NPOGS(IPT))
            SI = GPSO(2,NPOGS(IPT))    
           
C     ------------------------------------
C     SHAPE FUNCTIONS (H), DERIVATIVES (P)
C     ------------------------------------	      

CB          CALL SHAP8NEWP1(RI,SI,H1)	
      CALL SHAP8NEW(RI,SI,H1,P)
         
          EGMAT1(IPT,1:NNM1) = H1(1:NNM1)
          EGMAT2(IPT,1:NNM2) = H2(1:NNM2)
C     --------------------------------      
          
	    I1 = NWG*(NPOGS(IPT)-1)
          DO K=1,9
	    SIG(K) = WOREL2(I1+K)
          ENDDO
	                                   	    
	    CALL POSVMS(SIG,VMISE)
          
          DO J = 1,9
                STG1 = SIG(J)
                STG2 = ABS(STG1)

                IF(STG2.LT.1e-7) THEN
                 SIG(J) = 0.0
                ENDIF
          ENDDO
          
      SIG_SAVE = SIG    
      I1 = NWG*(NPOGS(IPT)-1) + 1
      !CALL SHSRLAX_SHL (WOREL2(I1),NWG,SIG_SAVE,SIG,'FIBER6')          
      CALL SHSRLAX_SHL (WOREL2(I1),NWG,SIG_SAVE,SIG,'RESULT')          
                  
C	------------------------------------------------------------------
C	COMPUTE FIBER STRESS AT GAUSS POINT
C	------------------------------------------------------------------
	ZETAG = 1!0.5*THK 
      !!SIG_FIBER = SIG
      SIG_FIBER(1)  = SIG(1) + ZETAG*SIG(3)
	SIG_FIBER(2)  = SIG(2) + ZETAG*SIG(4)
	SIG_FIBER(4)  = SIG(9) + ZETAG*SIG(5)
	SIG_FIBER(3)  = 0.0D0
	SIG_FIBER(5)  = SIG(6)
	SIG_FIBER(6)  = SIG(8)
      
      SIG_FIBER(7)  = 0.0!SIG(7)!0.0D0
      SIG_FIBER(8)  = 0.0!SIG(8)!0.0D0
      SIG_FIBER(9)  = 0.0!SIG(9)!0.0D0
                  
      
      SIG = SIG_FIBER
      
      SGVEC1(IPT,1:9) = SIG(1:9)    !FOR EXTRAPOLATION
      SGVEC1(IPT,10 ) = VMISE       !FOR EXTRAPOLATION      
      
      !!SIG = SIG_FIBER
C     ---------------------------------------------------------------------             
          
          NUM = LENGTH*(IPT-1)
                    
	    EDAT(NUM + 1) = SIG(1)  
	    EDAT(NUM + 2) = SIG(2)  
	    EDAT(NUM + 3) = SIG(3)  
	    EDAT(NUM + 4) = SIG(4)  
	    EDAT(NUM + 5) = SIG(5)  
	    EDAT(NUM + 6) = SIG(6)
	    EDAT(NUM + 7) = SIG(7)
	    EDAT(NUM + 8) = SIG(8)
	    EDAT(NUM + 9) = SIG(9)
	    EDAT(NUM +10) = VMISE
    	        		    
            
900	ENDDO
C     ----------------------
C     END OVER GAUSS POINTS
C     ----------------------

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
C----- 1. INTERPOLATE TO 4 NODES 
      EXMAT1 = MATMUL(TRANSPOSE(EGMAT1),EGMAT1)
	CALL INVMATRIX(EXMAT1,EXMATI1,NNM1)
	STVEC1 = MATMUL(EXMATI1,MATMUL(TRANSPOSE(EGMAT1),SGVEC1))
               
      !TO CONTROL SHEAR(ST) ---------
      STVEC1_DUM = STVEC1
      
      !!STVEC1(1,9) = STVEC1_DUM(3,9)
      !!STVEC1(2,9) = STVEC1_DUM(4,9)
      !!STVEC1(3,9) = STVEC1_DUM(1,9)
      !!STVEC1(4,9) = STVEC1_DUM(2,9)
      !-----------------------------      
	
C----- 2. INTERPOLATE WITH THICKNESS DIRECTION

CB    EXMAT2 = MATMUL(TRANSPOSE(EGMAT2),EGMAT2)
CB	CALL INVMATRIX(EXMAT2,EXMATI2,NNM2)
CB	STVEC2 = MATMUL(EXMATI2,MATMUL(TRANSPOSE(EGMAT2),STVEC1))	


C----- 2-1. CALL DISPLACEMENT OF EACH NODES
      
CDIS	DO ISN = 1,NSN
CDIS	    DO I = 1,NOUT2
CDIS	      CALL RELFILL('ONDS',DISPDAT(I),I,ISN,0)  
CDIS	    ENDDO
CDIS          DISPN(ISN,1:3) = DISPDAT(1:3)      
CDIS	ENDDO
	

C----- 2-2. CALL MATRIX FOR DETECTING THE THIN DIRECTION 
      
C           ILVNUM(IEL,8)

C----- 2-3. CALL MATRIX FOR CONNECTIVITY
            
CDIS        LM(IEL,1:8) = IA(LCN+(24*(IEL-1)):LCN+(24*(IEL-1))+7) 
        
      DO JEL = 1,NELE
        LM(JEL,1:8) = IA(LCN+(24*(JEL-1)):LCN+(24*(JEL-1))+7) 
	  DO JSN = 1,8
	      IM = LM(JEL,JSN) 
	      DISPN(IM,1:3) = SDISL(JEL,1+(3*(JSN-1)):3+(3*(JSN-1)))
CDIS	      DISPN(IM,1:3) = SDISL(IEL,1:3)
CDIS            DISPN(IM,1) = SDISL(JEL,1+3*(JSN-1))
CDIS            DISPN(IM,2) = SDISL(JEL,3+3*(JSN-1))
CDIS            DISPN(IM,3) = SDISL(JEL,2+3*(JSN-1))
	  ENDDO
      ENDDO

C------2-4. CALCULATE DISPLACEMENT IN MID-SURFACE
     
      DO I=1,3
	DO J=1,4
	    JJ  = ILVNUM(J)
	    JJJ = ILVNUM(J+4)
CNUM          JJ  = ILVNUM2(IEL,J)
CNUM          JJJ = ILVNUM2(IEL,J+4)
CNUM1          JJ = J
CNUM1          JJJ = J+4
	    IM1 = LM(IEL,JJ)
	    IM2 = LM(IEL,JJJ)
          DISPM(J,I)=(DISPN(IM1,I)+DISPN(IM2,I))/2. !DISPLACEMENT IN MID-SURFACE            
          
          DISPU(J,I) = DISPN(IM1,I)
          DISPL(J,I) = DISPN(IM2,I)
          
	ENDDO
	ENDDO

C------2-5. CALCULATE RATIO OF STRESS/DISPLACEMENT
      RATIOM = 0.0
      
      DO 1000 IR = 1,4    
      
      RA1 = DISPM(IR,1) !X = R
      RA2 = DISPM(IR,2) !Y = S
      RA3 = DISPM(IR,3) !Z = T
      

      
      ABRA1 = ABS(RA1)
      ABRA2 = ABS(RA2)
      ABRA3 = ABS(RA3)


C ----- EXPLANATION FOR RATIO MATIX -----      
C     FOR MEMBRANE R,S,RS      
C        RATIOM(IR,1) = STVEC1(IR,1)/RA1          
C        RATIOM(IR,2) = STVEC1(IR,2)/RA2
C        RATIOM(IR,3) = STVEC1(IR,3)/RA3
C     FOR BENDING RR,SS,RS              
C        RATIOM(IR,4) = STVEC1(IR,4)/RA1
C        RATIOM(IR,5) = STVEC1(IR,5)/RA2
C        RATIOM(IR,6) = STVEC1(IR,6)/RA3
C     FOR TRANSVERSE NORMAL TT              
C        RATIOM(IR,7) = STVEC1(IR,7)/RA3
C     FOR TRANSVERSE SHEAR RT,ST
C        RATIOM(IR,8) = STVEC1(IR,8)/RA1
C        RATIOM(IR,9) = STVEC1(IR,9)/RA2      
C ----------------------------------------      
      IF(ABRA1.EQ.0) THEN
C       FOR R
         RATIOM(IR,1) = 1      
C       FOR RS
         RATIOM(IR,4) = 1         
      ELSE
         RATIOM(IR,1) = STVEC1(IR,1)/RA1 !R
         RATIOM(IR,4) = STVEC1(IR,4)/RA3 !T
         
       ENDIF

      IF(ABRA2.EQ.0) THEN 
C       FOR S 
         RATIOM(IR,2) = 1                      
      ELSE
         RATIOM(IR,2) = STVEC1(IR,2)/RA3 !S

      ENDIF

      IF(ABRA3.EQ.0) THEN
C       FOR T        
         RATIOM(IR,3) = 1               
C       FOR RT
         RATIOM(IR,5) = 1
C       FOR ST
         RATIOM(IR,6) = 1                  
CR      FOR TRANSVERSE NORMAL TT  
         RATIOM(IR,7) = 1       
CR      FOR TRANSVERSE SHEAR RT
         RATIOM(IR,8) = 1   
CR      FOR TRANSVERSE SHEAR ST
         RATIOM(IR,9) = 1                
      ELSE       
         RATIOM(IR,3) = STVEC1(IR,3)/RA3 !T  
         RATIOM(IR,5) = STVEC1(IR,5)/RA3 !RS 
         RATIOM(IR,6) = STVEC1(IR,6)/RA3 !ST      
         
         RATIOM(IR,7) = STVEC1(IR,7)/RA3 !T
         RATIOM(IR,8) = STVEC1(IR,8)/RA3 !T
         RATIOM(IR,9) = STVEC1(IR,9)/RA3 !T
      ENDIF
          
    
1000    ENDDO

C------2-6. CALCULATE UPPER/LOWER DISP WITH RATIO

      DO IS = 1,4
       DO IM = 1,3    
       DU = DISPU(IS,IM)
       DL = DISPL(IS,IM)
          IF(DU.EQ.0) THEN
            STRESSNU(IS,IM) = STVEC1(IS,IM)
            STRESSNU(IS,IM+3) = STVEC1(IS,IM+3)
          ELSE        
C     FOR R,S,T
            IF(IM.EQ.1) THEN
             STRESSNU(IS,IM) = STVEC1(IS,IM)    
            ELSE
              STRESSNU(IS,IM) = RATIOM(IS,IM)*DISPU(IS,3) !R  
            ENDIF                              
C     FOR RS,ST,ST
            !!STRESSNU(IS,IM+3) = RATIOM(IS,IM+3)*DISPU(IS,3) !T                      
            STRESSNU(IS,IM+3) = STVEC1(IS,IM+3)
CR            STRESSNU(IS,IM+3) = RATIOM(IS,IM+3)*DISPU(IS,IM)
          ENDIF
      
          IF(DL.EQ.0) THEN
            STRESSNL(IS,IM) = STVEC1(IS,IM)
            STRESSNL(IS,IM+3) = STVEC1(IS,IM+3)
          ELSE        
C     FOR R,S,T
            IF(IM.EQ.1) THEN              
             STRESSNL(IS,IM) = STVEC1(IS,IM)    
            ELSE
              STRESSNL(IS,IM) = RATIOM(IS,IM)*DISPL(IS,3) !R          
            ENDIF                             
C     FOR RS,ST,ST
            !!STRESSNL(IS,IM+3) = RATIOM(IS,IM+3)*DISPL(IS,3) !T           
            STRESSNL(IS,IM+3) = STVEC1(IS,IM+3)
CR          STRESSNL(IS,IM+3) = RATIOM(IS,IM+3)*DISPL(IS,IM)       
          ENDIF
       ENDDO
      ENDDO

      
C     FOR TRANSVERSE NORMAL TT
      DO IS = 1,4  
       DU = DISPU(IS,IM)
       DL = DISPL(IS,IM)
      IF(DU.EQ.0) THEN
        STRESSNU(IS,7) = STVEC1(IS,7)     
      ELSE
        STRESSNU(IS,7) = RATIOM(IS,7)*DISPU(IS,3) !T  
      ENDIF

      IF(DL.EQ.0) THEN  
        STRESSNL(IS,7) = STVEC1(IS,7)
      ELSE
        STRESSNL(IS,7) = RATIOM(IS,7)*DISPL(IS,3) !T  
      ENDIF
        
      ENDDO

C     FOR TRANSVERSE SHEAR RT,ST
      DO IS = 1,4
       DO IM = 1,2
        DU = DISPU(IS,IM)
        DL = DISPL(IS,IM)
        
        !!IF(DU.EQ.0) THEN
        STRESSNU(IS,IM+7) = STVEC1(IS,IM+7)
        !!ELSE
        !!STRESSNU(IS,IM+7) = RATIOM(IS,IM+7)*DISPU(IS,3) !T        
        !!ENDIF
        
        !!IF(DL.EQ.0) THEN
        STRESSNL(IS,IM+7) = STVEC1(IS,IM+7)
        !!ELSE
        !!STRESSNL(IS,IM+7) = RATIOM(IS,IM+7)*DISPL(IS,3) !T         
        !!ENDIF
        
       ENDDO
      ENDDO
            
C------2-7. CHANGE THE ORDER OF STRESS MATRIX TO CORRESPOND WITH ORDER OF CONNECTIVITY

CNUM       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
CNUM       STRESSNUN(2,1:9) = STRESSNL(2,1:9)
CNUM       STRESSNUN(3,1:9) = STRESSNU(4,1:9)
CNUM       STRESSNUN(4,1:9) = STRESSNL(3,1:9)
    
CNUM       STRESSNLN(1,1:9) = STRESSNL(1,1:9)
CNUM       STRESSNLN(2,1:9) = STRESSNU(2,1:9)
CNUM       STRESSNLN(3,1:9) = STRESSNL(4,1:9)
CNUM       STRESSNLN(4,1:9) = STRESSNU(3,1:9)
       
      IF(NMX.EQ.1) THEN
       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
       STRESSNUN(2,1:9) = STRESSNL(2,1:9)
       STRESSNUN(3,1:9) = STRESSNU(4,1:9)
       STRESSNUN(4,1:9) = STRESSNL(3,1:9)
    
       STRESSNLN(1,1:9) = STRESSNL(1,1:9)
       STRESSNLN(2,1:9) = STRESSNU(2,1:9)
       STRESSNLN(3,1:9) = STRESSNL(4,1:9)
       STRESSNLN(4,1:9) = STRESSNU(3,1:9)       


       DO I = 1,4
        DO J = 1,9
        
            STU1 = STRESSNUN(I,J)
            STL1 = STRESSNLN(I,J) 
            
            STU2 = ABS(STU1)
            STL2 = ABS(STL1)
            
            IF(STU2.LT.1e-10) THEN
                STRESSNUN(I,J) = 0.0
            ENDIF
            
            IF(STL2.LT.1e-10) THEN
                STRESSNLN(I,J) = 0.0
            ENDIF        
            
        ENDDO
       ENDDO

C------2-8. STORE THE UPPER & LOWER STRESSES INTO STVEC2 MATRIX

       DO I = 1,4
         STVEC2(2*I-1,1:9) = STRESSNUN(I,1:9)
         STVEC2(2*I,1:9) = STRESSNLN(I,1:9)
       ENDDO
      
      ELSEIF(NMX.EQ.2) THEN
     
       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
       STRESSNUN(2,1:9) = STRESSNL(4,1:9)
       STRESSNUN(3,1:9) = STRESSNU(2,1:9)
       STRESSNUN(4,1:9) = STRESSNL(3,1:9)
    
       STRESSNLN(1,1:9) = STRESSNU(4,1:9)
       STRESSNLN(2,1:9) = STRESSNL(1,1:9)
       STRESSNLN(3,1:9) = STRESSNU(3,1:9)
       STRESSNLN(4,1:9) = STRESSNL(2,1:9)      


       DO I = 1,4
        DO J = 1,9
        
            STU1 = STRESSNUN(I,J)
            STL1 = STRESSNLN(I,J) 
            
            STU2 = ABS(STU1)
            STL2 = ABS(STL1)
            
            IF(STU2.LT.1e-10) THEN
                STRESSNUN(I,J) = 0.0
            ENDIF
            
            IF(STL2.LT.1e-10) THEN
                STRESSNLN(I,J) = 0.0
            ENDIF        
            
        ENDDO
       ENDDO
       
C------2-8. STORE THE UPPER & LOWER STRESSES INTO STVEC2 MATRIX

       DO I = 1,4
         STVEC2(2*I-1,1:9) = STRESSNUN(I,1:9)
         STVEC2(2*I,1:9) = STRESSNLN(I,1:9)
       ENDDO
       
       ELSEIF(NMX.EQ.3) THEN
     
       STRESSNUN(1,1:9) = STRESSNU(1,1:9)
       STRESSNUN(2,1:9) = STRESSNU(2,1:9)
       STRESSNUN(3,1:9) = STRESSNU(3,1:9)
       STRESSNUN(4,1:9) = STRESSNU(4,1:9)
    
       STRESSNLN(1,1:9) = STRESSNL(1,1:9)
       STRESSNLN(2,1:9) = STRESSNL(2,1:9)
       STRESSNLN(3,1:9) = STRESSNL(3,1:9)
       STRESSNLN(4,1:9) = STRESSNL(4,1:9)       


       DO I = 1,4
        DO J = 1,9
        
            STU1 = STRESSNUN(I,J)
            STL1 = STRESSNLN(I,J) 
            
            STU2 = ABS(STU1)
            STL2 = ABS(STL1)
            
            IF(STU2.LT.1e-10) THEN
                STRESSNUN(I,J) = 0.0
            ENDIF
            
            IF(STL2.LT.1e-10) THEN
                STRESSNLN(I,J) = 0.0
            ENDIF        
            
        ENDDO
       ENDDO

C------2-8. STORE THE UPPER & LOWER STRESSES INTO STVEC2 MATRIX

      DO I = 1,4
        STVEC2(I,1:9) = STRESSNUN(I,1:9)
        STVEC2(I+4,1:9) = STRESSNLN(I,1:9)
      ENDDO
                   
      ENDIF      
       
C	------------------------------------------------------------------
C	COMPUTE FIBER STRESS FOR NODAL
C	------------------------------------------------------------------
	ZETAG = 1!0.5*THK 
      !STVEC2_FIBER = STVEC2
      STVEC2_FIBER(1:NNM2,1)  = STVEC2(1:NNM2,1) + ZETAG*STVEC2(1:NNM2,3)
	STVEC2_FIBER(1:NNM2,2)  = STVEC2(1:NNM2,2) + ZETAG*STVEC2(1:NNM2,4)
	STVEC2_FIBER(1:NNM2,4)  = STVEC2(1:NNM2,6) + ZETAG*STVEC2(1:NNM2,5)
	STVEC2_FIBER(1:NNM2,3)  = 0.0D0
	STVEC2_FIBER(1:NNM2,5)  = STVEC2(1:NNM2,8)
	STVEC2_FIBER(1:NNM2,6)  = STVEC2(1:NNM2,9)
      
      STVEC2_FIBER(1:NNM2,7)  = STVEC2(1:NNM2,7)!0.0D0
      STVEC2_FIBER(1:NNM2,8)  = STVEC2(1:NNM2,8)!0.0D0
      STVEC2_FIBER(1:NNM2,9)  = STVEC2(1:NNM2,9)!0.0D0
      
      !!STVEC2 = STVEC2_FIBER
C     ---------------------------------------------------------------------        

	DO INM = 1,NNM2 
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC2(INM,1:LENGTH) 
	ENDDO
	
	

      READ(NFL5,REC=IEL) AF2(1:N1)  
	    DO I = 1,NOUT
	        VALV = EDAT(I)
	        AF2(I     ) = VALV  !POSITIVE
	        AF2(I+NOUT) = VALV  !NEGATIVE
          ENDDO		
      WRITE(NFL5,REC=IEL) AF2(1:N1)  	
C	--------------
	
          
800	ENDDO

	DEALLOCATE(AF2,EDAT,WOREL2)      
	
	DEALLOCATE(EXMAT1,EXMATI1,STVEC1,EGMAT1,SGVEC1,STVEC1_DUM)
	DEALLOCATE(EXMAT2,EXMATI2,STVEC2,EGMAT2,SGVEC2,SIG_FIBER,STVEC2_FIBER)
	
	DEALLOCATE(DISPDAT,DISPN)
CB	DEALLOCATE(INMX)
CB	DEALLOCATE(ILVNUM)
	DEALLOCATE(ILVNUM2)
	DEALLOCATE(LM)
      DEALLOCATE(DISPU,DISPL)
CDIS      DEALLOCATE(SDISL)

      RETURN
      END

C	=================================================================
C	=================================================================
C	================================================================= 
      SUBROUTINE SCPOUT(KEG,NODEX,MEX)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------
	DIMENSION NPOGS(27),SIG(6)

	DIMENSION NODEX(MEX,1),GPSO(3,27),H(27),HD(3,27)
	
	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)
	
	ALLOCATABLE EGMAT(:,:),EXMAT(:,:),EXMATI(:,:),SGVEC(:,:),STVEC(:,:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',LENGTH,17,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))
	
C     -------------------------------
C     -------------------------------
	ALLOCATE(EGMAT(NPT,NNM),EXMAT(NNM,NNM),EXMATI(NNM,NNM))
	
      SELECTCASE(ISTYP)
      CASE(2)   !8 NODE HEXA
	NPOGS(1:8) = [7,3,1,5,8,4,2,6]
	 GPSO(1:3,1) = [-0.57735026918963,-0.57735026918963,-0.57735026918963]
	 GPSO(1:3,2) = [-0.57735026918963,-0.57735026918963,+0.57735026918963]
	 GPSO(1:3,3) = [-0.57735026918963,+0.57735026918963,-0.57735026918963]
	 GPSO(1:3,4) = [-0.57735026918963,+0.57735026918963,+0.57735026918963]
	 GPSO(1:3,5) = [+0.57735026918963,-0.57735026918963,-0.57735026918963]
	 GPSO(1:3,6) = [+0.57735026918963,-0.57735026918963,+0.57735026918963]
	 GPSO(1:3,7) = [+0.57735026918963,+0.57735026918963,-0.57735026918963]
	 GPSO(1:3,8) = [+0.57735026918963,+0.57735026918963,+0.57735026918963]
	CASE DEFAULT
	 RETURN
	ENDSELECT

	ALLOCATE(SGVEC(NPT,LENGTH),STVEC(NNM,LENGTH))
C     ---------------------------------



      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

C     ---------------
      DO IPT=1,NPT

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES 
C     --------------------------------
      RI = GPSO(1,NPOGS(IPT))
      SI = GPSO(2,NPOGS(IPT))
      TI = GPSO(3,NPOGS(IPT))

      SELECTCASE(ISTYP)
      CASE(2)   !8 NODE HEXA
      CALL SHAP3D (RI,SI,TI,H,HD,NODEX(1,IEL),NNM)
	ENDSELECT

      EGMAT(IPT,1:NNM) = H(1:NNM)
C     --------------------------------       
      
	I1 = NWG*(NPOGS(IPT)-1)
      DO K=1,6
	SIG(K) = WOREL(I1+K)
	ENDDO
	CALL POSVMS(SIG,VMISE)

	NUM = LENGTH*(IPT-1)
	EDAT(NUM + 1) = SIG(1)  
	EDAT(NUM + 2) = SIG(2)  
	EDAT(NUM + 3) = SIG(3)  
	EDAT(NUM + 4) = SIG(4)  
	EDAT(NUM + 5) = SIG(5)  
	EDAT(NUM + 6) = SIG(6)  
	EDAT(NUM + 7) = VMISE
	
      SGVEC(IPT,1:6) = SIG(1:6)    !FOR EXTRAPOLATION
      SGVEC(IPT,7  ) = VMISE       !FOR EXTRAPOLATION
      
	ENDDO
C     ---------------

C     --------------------------------
C     EXTRAPOLATE STRESS TO NODES
C     --------------------------------
      EXMAT = MATMUL(TRANSPOSE(EGMAT),EGMAT)
	CALL INVMATRIX(EXMAT,EXMATI,NNM)
	STVEC = MATMUL(EXMATI,MATMUL(TRANSPOSE(EGMAT),SGVEC))
	DO INM = 1,NNM
	    NUM = (LENGTH)*(NPT) + (LENGTH)*(INM-1)
	    EDAT(NUM + 1:NUM + LENGTH) = STVEC(INM,1:LENGTH) 
	ENDDO
C     --------------------------------

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1)  
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1)  		
C	--------------
	
	ENDDO
	
	DEALLOCATE(AF1,EDAT,WOREL)

	DEALLOCATE(EXMAT,EXMATI,STVEC,EGMAT,SGVEC)
	
      RETURN
      END


C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE F2POUT(KEG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     --------------------------------------------------------------
	DIMENSION NPOGS(27),VEL(2)

	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))
	
	REWIND(NFL1)
	READ(NFL1) AF1
C	--------------------------------------------------------------
C	--------------------------------------------------------------	
	IF(NPT.EQ.3) THEN  
	NPOGS(1) = 1
	NPOGS(2) = 2
	NPOGS(3) = 3
	ELSEIF(NPT.EQ.4) THEN  
	NPOGS(1) = 4
	NPOGS(2) = 2
	NPOGS(3) = 1
	NPOGS(4) = 3
	ELSEIF(NPT.EQ.9) THEN
	NPOGS(1) = 9
	NPOGS(2) = 3
	NPOGS(3) = 1
	NPOGS(4) = 7
	NPOGS(5) = 6
	NPOGS(6) = 2
	NPOGS(7) = 4
	NPOGS(8) = 8
	NPOGS(9) = 5
	ENDIF


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

      DO IPT=1,NPT
	I1 = NWG*(NPOGS(IPT)-1) + 1
	VEL(1:2) = 0.0D0
	VEL(1)   = WOREL(I1  )
	VEL(2)   = WOREL(I1+1)
	NUM = 2*(IPT-1)
	EDAT(NUM + 1) = VEL(1)
	EDAT(NUM + 2) = VEL(2)
	ENDDO

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1)  
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1)  		
C	--------------	

	ENDDO

	
	DEALLOCATE(AF1,EDAT,WOREL)

	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE F3POUT(KEG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------
	DIMENSION NPOGS(27),VEL(3)

	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))

C     -------------------------------
C     -------------------------------

	IF(NPT.EQ.8) THEN
	NPOGS(1) = 7
	NPOGS(2) = 3
	NPOGS(4) = 5
	NPOGS(3) = 1
	NPOGS(5) = 8
	NPOGS(6) = 4
	NPOGS(8) = 6
	NPOGS(7) = 2
	ENDIF
	IF(NPT.EQ.4) THEN
	NPOGS(1) = 2
	NPOGS(2) = 1
	NPOGS(3) = 4
	NPOGS(4) = 3
	ENDIF
C     ---------------------------------


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

      DO IPT=1,NPT
	I1 = NWG*(NPOGS(IPT)-1)
C
      DO K=1,3
	VEL(K) = WOREL(I1+K)
	ENDDO

	NUM = 3*(IPT-1)
	EDAT(NUM + 1) = VEL(1)  
	EDAT(NUM + 2) = VEL(2)  
	EDAT(NUM + 3) = VEL(3)  
	ENDDO

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1)  
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1)  		
C	--------------
	
	ENDDO

	
	DEALLOCATE(AF1,EDAT,WOREL)

      RETURN
      END


C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE H2POUT(KEG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     --------------------------------------------------------------
	DIMENSION NPOGS(27),VEL(2)

	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))
	
C	--------------------------------------------------------------
C	--------------------------------------------------------------	
	IF(NPT.EQ.3) THEN  
	NPOGS(1) = 1
	NPOGS(2) = 2
	NPOGS(3) = 3
	ELSEIF(NPT.EQ.4) THEN  
	NPOGS(1) = 4
	NPOGS(2) = 2
	NPOGS(3) = 1
	NPOGS(4) = 3
	ELSEIF(NPT.EQ.9) THEN
	NPOGS(1) = 9
	NPOGS(2) = 3
	NPOGS(3) = 1
	NPOGS(4) = 7
	NPOGS(5) = 6
	NPOGS(6) = 2
	NPOGS(7) = 4
	NPOGS(8) = 8
	NPOGS(9) = 5
	ENDIF


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

      DO IPT=1,NPT
	I1 = NWG*(NPOGS(IPT)-1) + 1
	VEL(1:2) = 0.0D0                !AT THE MOMENT NOTHING ARE PRINTING 
	NUM = 2*(IPT-1)
	EDAT(NUM + 1) = VEL(1)
	EDAT(NUM + 2) = VEL(2)
	ENDDO

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1)  
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO
          WRITE(NFL1,REC=IEL) AF1(1:N1)  			
C	--------------	

	ENDDO


	DEALLOCATE(AF1,EDAT,WOREL)

	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE H3POUT(KEG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ---------------------------------------------------------------
	DIMENSION NPOGS(27),VEL(3)

	DIMENSION NPM(10),NPI(10)
	ALLOCATABLE AF1(:),EDAT(:),WOREL(:)

	IEG = KEG
C	GROUP DATA
	CALL INTFILL('OGRP',ITYPE,1 ,IEG,0) !
	CALL INTFILL('OGRP',ISTYP,2 ,IEG,0) !
	CALL INTFILL('OGRP',MTMOD,3 ,IEG,0) !
	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRP',NPT  ,5 ,IEG,0) !
	CALL INTFILL('OGRP',NEF  ,6 ,IEG,0) !
	CALL INTFILL('OGRP',NNM  ,7 ,IEG,0) !
	CALL INTFILL('OGRP',NNF  ,8 ,IEG,0) !
	CALL INTFILL('OGRP',NGR  ,9 ,IEG,0) !
	CALL INTFILL('OGRP',NGS  ,10,IEG,0) !
	CALL INTFILL('OGRP',NGT  ,11,IEG,0) !
	CALL INTFILL('OGRP',NOUT ,12,IEG,0) !
	CALL INTFILL('OGRP',NMP  ,13,IEG,0) !
	CALL INTFILL('OGRP',NGP  ,14,IEG,0) !
	CALL INTFILL('OGRP',NWA  ,15,IEG,0) !
	CALL INTFILL('OGRP',NLOPT,16,IEG,0) !
	CALL INTFILL('OGRP',NWG  ,18,IEG,0) !
C	GROUP FILE
	CALL INTFILL('OGRF',N1   ,1 ,IEG,0) !
	CALL INTFILL('OGRF',NFL1 ,11,IEG,0) !

	ALLOCATE(AF1(N1),EDAT(NOUT),WOREL(NWA))
	
C     -------------------------------
C     -------------------------------

	IF(NPT.EQ.8) THEN
	NPOGS(1) = 7
	NPOGS(2) = 3
	NPOGS(4) = 5
	NPOGS(3) = 1
	NPOGS(5) = 8
	NPOGS(6) = 4
	NPOGS(8) = 6
	NPOGS(7) = 2
	ENDIF
	IF(NPT.EQ.4) THEN
	NPOGS(1) = 2
	NPOGS(2) = 1
	NPOGS(3) = 4
	NPOGS(4) = 3
	ENDIF
C     ---------------------------------


      DO IEL=1,NELE

	CALL ADREWT(KEG,IEL,WOREL,'RED')

      DO IPT=1,NPT
	I1 = NWG*(NPOGS(IPT)-1)
C
      DO K=1,3
	VEL(K) = 0.0D0                !AT THE MOMENT NOTHING ARE PRINTING 
	ENDDO

	NUM = 3*(IPT-1)
	EDAT(NUM + 1) = VEL(1)  
	EDAT(NUM + 2) = VEL(2)  
	EDAT(NUM + 3) = VEL(3)  
	ENDDO

C	--------------

          READ(NFL1,REC=IEL) AF1(1:N1)  
	    DO I = 1,NOUT
	    VALV = EDAT(I)
	    AF1(I     ) = VALV  !POSITIVE
	    AF1(I+NOUT) = VALV  !NEGATIVE
	    ENDDO	
          WRITE(NFL1,REC=IEL) AF1(1:N1)  		
C	--------------
	
	ENDDO

	
	DEALLOCATE(AF1,EDAT,WOREL)

      RETURN
      END


C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE LIKOUT
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	-------------------------------------------------------------------
      COMMON /MGLENK/ NGLELM,NGLSET,LNKLEN,LNKWRK,LNKFRE,LEKNOD(5000) 
      COMMON /DTLENK/ DATLNK(50000),WATLNK(50000) 
C	-------------------------------------------------------------------	
	DIMENSION SIG(6)
	ALLOCATABLE EDAT(:)

	IF(NGLELM.EQ.0) RETURN


	CALL LOCATN('OLNK',KLNK,NOUT2,NOUT1,2)
	NOUT = NOUT2/2
	ALLOCATE(EDAT(NOUT))

	DO IELE = 1,NGLELM

	NUM = 3*(IELE-1)   
	IN1 = LEKNOD(1+NUM)
	IN2 = LEKNOD(2+NUM)

	EDAT(1) = FLOAT(IN1)  !I NODE NO.
	EDAT(2) = FLOAT(IN2)  !J NODE NO.

	MUM = LNKWRK*(IELE-1)
	DO J = 1,6
	EDAT(2+J) = WATLNK(J+MUM)
	ENDDO

C	--------------
	DO I = 1,NOUT
	VALV = EDAT(I)
	NUM = I
	CALL RELFILL('OLNK',VALV,NUM,IELE,1)
	NUM = I+NOUT
	CALL RELFILL('OLNK',VALV,NUM,IELE,1)
	ENDDO			
C	--------------

	ENDDO

	DEALLOCATE(EDAT)


	RETURN
	END
C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE RCTOUT(IDSET,DIRCOS,LSUPF,REACT,MSN,MSF)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM
	DIMENSION REAC(9),LSUPF(MSF,MSN),REACT(1)
	DIMENSION IDSET(1),DIRCOS(9,1)
	DIMENSION RAEL(9)

	ALLOCATABLE EDATG(:),EDATL(:)
	ALLOCATABLE RTION(:,:),REACL(:,:)
      
      ALLOCATE(RTION(NSN,10),REACL(NSN,10))

	CALL LOCATN('OGSP',KSUPG,NOUT2,NOUT1,2)
	NOUTG = NOUT2/2
	ALLOCATE(EDATG(NOUTG))
	EDATG = 0.0D0

	CALL LOCATN('OLSP',KSUPL,NOUT2,NOUT1,2)
	NOUTL = NOUT2/2
	ALLOCATE(EDATL(NOUTL))
      EDATL = 0.0D0



	LOCAF = 0  !FLAG FOr LOCAL SUPPORT

	DO ISN = 1,NSN !LOOP OVER NODE

	REAC = 0.0D0
	RAEL = 0.0D0

	NS = IDSET(ISN)
	
	LTEST = 0
	DO IDO = 1,MSF
	IFQ = LSUPF(IDO,ISN)

C	--------------------------------------------------------
C	THIS BLOCK FOR FULLY RESTRAINT 
	IF(IFQ.NE.0) THEN  !!!!!!!!

	IKK = 0
	DO II = 1,MSF
	IF(LSUPF(II,ISN).NE.0) IKK = IKK+1
	ENDDO

	IF(IKK.EQ.MSF.AND.NLS.EQ.0) THEN  !FULLY RESTRAINT GLOBAL
	REAC(IDO) = REACT(IFQ)
	LTEST = 1
	GO TO 100
	ENDIF
	
	IF(IKK.EQ.MSF.AND.NS.NE.0 ) THEN  !FULLY RESTRAINT LOCAL  
	REAC(IDO) = REACT(IFQ)  !GLOBAL REACTION DIRECTLY TAKEN FROM DATA
C	TRANSFORM THE FORCE TO LOCAL SUPPORT
	IF(IDO.LE.3) THEN
	KDOF = IDO
	RAEL(1) = RAEL(1) + DIRCOS(KDOF+0,NS)*REACT(IFQ)
	RAEL(2) = RAEL(2) + DIRCOS(KDOF+3,NS)*REACT(IFQ)
	RAEL(3) = RAEL(3) + DIRCOS(KDOF+6,NS)*REACT(IFQ)
	ENDIF
	IF(IDO.GE.4.AND.IDO.LE.6) THEN
	KDOF = IDO-3
	RAEL(4) = RAEL(4) + DIRCOS(KDOF+0,NS)*REACT(IFQ)
	RAEL(5) = RAEL(5) + DIRCOS(KDOF+3,NS)*REACT(IFQ)
	RAEL(6) = RAEL(6) + DIRCOS(KDOF+6,NS)*REACT(IFQ)
	ENDIF
	IF(IDO.GT.6) THEN
	RAEL(IDO) = REACT(IFQ)
	ENDIF
	LOCAF = 1
	GO TO 100
	ENDIF

	ENDIF           !ENF IF(IFQ.NE.0)
C	--------------------------------------------------------
C	THIS BLOCK FOR GLOBAL PARTIAL RESTRAINT WITHOUT LOCAL AXIS
	IF(IFQ.NE.0.AND.NLS.EQ.0) THEN
	REAC(IDO) = REACT(IFQ)
	LTEST = 1
	GO TO 100
	ENDIF
C	------------------------------------------------
C	THIS BLOCK FOR GLOBAL SUPPORT ONLY
	IF(IFQ.NE.0.AND.NS.EQ.0) THEN
	REAC(IDO) = REACT(IFQ)
	LTEST = 1
	GOTO 100
	ENDIF
C	------------------------------------------------
C	THIS BLOCK TRANSFORM THE FORCE TO GLOBAL SUPPORT
	IF(IFQ.NE.0.AND.NS.NE.0) THEN

	RAEL(IDO) = REACT(IFQ)  !SKEW SUPPORT REACTION DIRECTLY TAKEN FROM DATA
C	TRANSFORM THE FORCE TO GLOBAL SUPPORT
	IF(IDO.LE.3) THEN
	KDOF = IDO
	REAC(1) = REAC(1) + DIRCOS(3*KDOF-2,NS)*REACT(IFQ)
	REAC(2) = REAC(2) + DIRCOS(3*KDOF-1,NS)*REACT(IFQ)
	REAC(3) = REAC(3) + DIRCOS(3*KDOF-0,NS)*REACT(IFQ)
	ENDIF
	IF(IDO.GE.4.AND.IDO.LE.6) THEN
	KDOF = IDO-3
	REAC(4) = REAC(4) + DIRCOS(3*KDOF-2,NS)*REACT(IFQ)
	REAC(5) = REAC(5) + DIRCOS(3*KDOF-1,NS)*REACT(IFQ)
	REAC(6) = REAC(6) + DIRCOS(3*KDOF-0,NS)*REACT(IFQ)
	ENDIF
	IF(IDO.GT.6) THEN
	REAC(IDO) = REACT(IFQ)
	ENDIF
	LOCAF = 1               !FLAG TO KNOW THAt LOCAL SUPPORT IS EXIST
	LTEST = 1
	GOTO 100 
	ENDIF
      
100	CONTINUE
C	------------------------------------------------
	ENDDO  !END LOOP OVER NDOF


	RTION(ISN,1:9) = 0.0D0
	REACL(ISN,1:9) = 0.0D0
	DO ISF = 1,NSF
	IIF = IDOF(ISF)
	RTION(ISN,IIF) = REAC(ISF)
	REACL(ISN,IIF) = RAEL(ISF)  !LOCAL REACTION
	ENDDO

200	CONTINUE
	ENDDO  !END LOOP OVER NODE

C	==========================================================


C	GLOBAL
	DO ISN = 1,NSN
	DO ISF = 1,9
	EDATG(ISF) = RTION(ISN,ISF)
	ENDDO
C	--------------
	DO I = 1,NOUTG
	VALV = EDATG(I)
      NUM = I
	CALL RELFILL('OGSP',VALV,NUM,ISN,1)
      NUM = I+NOUTG
	CALL RELFILL('OGSP',VALV,NUM,ISN,1)
	ENDDO			
C	--------------
	ENDDO


C	LOCAL
	DO ISN = 1,NSN
	DO ISF = 1,9
	EDATL(ISF) = REACL(ISN,ISF)
	ENDDO
C	--------------
	DO I = 1,NOUTL
	VALV = EDATL(I)
      NUM = I
	CALL RELFILL('OLSP',VALV,NUM,ISN,1)
      NUM = I+NOUTL
	CALL RELFILL('OLSP',VALV,NUM,ISN,1)
	ENDDO			
C	--------------
	ENDDO


	DEALLOCATE(EDATG)
	DEALLOCATE(EDATL)

      DEALLOCATE(RTION,REACL)


	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================
	SUBROUTINE DISOUT(ID,DISP)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON A(9000000),IA(9000000)

C	REACTION BY SONGSAK APR2006
	COMMON /REACT/ LRC,LRCT,MFQ,LRID

	DIMENSION ID(NSF,1),D(9),DISP(1)

	ALLOCATABLE EDAT(:)
	CALL LOCATN('ONDS',KDISP,NOUT2,NOUT1,2)
	NOUT = NOUT2/2
	ALLOCATE(EDAT(NOUT))
      EDAT = 0.0D0

      DO 1250  ISN=1,NSN
	CALL CLEARA (D,9)

      DO 1210  ISF=1,NSF
      IPO = IDOF(ISF)
      IEQ = ID(ISF,ISN)
	IF (IEQ.NE.0)  D(IPO) = DISP(IEQ)
	CALL SETPRN (D,IA(LRID),IA(LID),ISN,ISF)
 1210	CONTINUE

      IF (NLS.GT.0) CALL LOCRES (ID,IA(LDS),A(LDC),D,D,D,D,D,NSF,ISN,3)
	
	DO I = 1,9
	EDAT(I) = D(I)
	ENDDO

C	--------------
	DO I = 1,NOUT
	VALV = EDAT(I)
	NUM = I
	CALL RELFILL('ONDS',VALV,NUM,ISN,1)
	NUM = I+NOUT
	CALL RELFILL('ONDS',VALV,NUM,ISN,1)
	ENDDO			
C	--------------


 1250 CONTINUE


	DEALLOCATE(EDAT)

	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================
	SUBROUTINE DISOUT_UNCONF(ID,XYZ,DISP)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
C	ADJUST THE POTENTIAL VALUE DUE TO FREE SURFACE ITERATION
C	----------------------------------------------------------------
	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

	COMMON /MGRAV/ NGRAV

      COMMON A(9000000),IA(9000000)

C	REACTION BY SONGSAK APR2006
	COMMON /REACT/ LRC,LRCT,MFQ,LRID

	DIMENSION ID(NSF,1),D(9),DISP(1),XYZ(NSN,1)

	ALLOCATABLE EDAT(:)
	CALL LOCATN('ONDS',KDISP,NOUT2,NOUT1,2)
	NOUT = NOUT2/2
	ALLOCATE(EDAT(NOUT))


      DO 1250  ISN=1,NSN
	CALL CLEARA (D,9)

      DO 1210  ISF=1,NSF
      IPO = IDOF(ISF)
      IEQ = ID(ISF,ISN)
	IF (IEQ.NE.0)  D(IPO) = DISP(IEQ)
	CALL SETPRN (D,IA(LRID),IA(LID),ISN,ISF)
 1210	CONTINUE

      IF (NLS.GT.0) CALL LOCRES (ID,IA(LDS),A(LDC),D,D,D,D,D,NSF,ISN,3)
	
	DO I = 1,9
	IF(I.EQ.9.AND.XYZ(ISN,NGRAV).GT.D(I)) D(I) = 0.0D0  !9 IS POTENTIAL DOF
	EDAT(I) = D(I)
	ENDDO

C	--------------
	DO I = 1,NOUT
	VALV = EDAT(I)
	NUM = I
	CALL RELFILL('ONDS',VALV,NUM,ISN,1)
	NUM = I+NOUT
	CALL RELFILL('ONDS',VALV,NUM,ISN,1)
	ENDDO			
C	--------------


 1250 CONTINUE
	

	DEALLOCATE(EDAT)

	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================
	SUBROUTINE SPGOUT(ID,SD,DISP,DISPI,NEQ,SD2,SDWOK)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=================================================================
	
      COMMON /FLAG/  IFPRI,ISPRI,IFPLO,IFREF,IFEIG,ITASK,IFFLAG

	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM

C	NEW SPRING SUPPORT SONGSAK JUL2006
	COMMON /SPBC/ NSS,NLSS


	DIMENSION ID(NSF,NSN),SD(6,NSN),DISP(NEQ),DISPI(NEQ),DIP(NEQ)
	DIMENSION SD2(42,NSS),SDWOK(30,NSS)
	DIMENSION ST2(7,6),SDW(5,6)


	ALLOCATABLE EDAT(:)
	CALL LOCATN('OGSS',KGSS,NOUT2,NOUT1,2)
	NOUT = NOUT2/2
	ALLOCATE(EDAT(NOUT))


	DO IEQ = 1,NEQ
	DIP(IEQ) = DISP(IEQ)
	IF(ITASK.EQ.2) DIP(IEQ) = DISP(IEQ)+DISPI(IEQ) 
	ENDDO


	DO ISS =1,NSS
	CALL CALFOS(SD2(1,ISS),SDWOK(1,ISS),ST2,SDW)
	
	EDAT(1:NOUT) = 0.0D0
	
		DO JJ = 1,NSF
		IF (JJ.LE.6) THEN
		II = ST2(1,JJ)

		EDAT(1) = FLOAT(II)   !SUPPORT NODE NO.

		IOPT2 = ST2(6,JJ)
		IEQ   = ID(JJ,II)
		YOUNG = SD(JJ,II)

			IF(IEQ.GT.0) THEN
			DD = DIP(IEQ)

			R21   = ST2(2,JJ)
			YOUN2 = YOUNG*R21
			FY    = ST2(3,JJ)
			DMAX  = ST2(4,JJ) 
			QFY   = ST2(5,JJ) 

			EPSP  = SDW(1,JJ)
			SIGP  = SDW(2,JJ) 
			EPSTN = SDW(3,JJ) 
			EPTTN = SDW(4,JJ) 

			CALL SPGPAS(EPSP,SIGP,DD,EDAT(1+JJ),YOUNG,YOUN2,
	1				    EPSTN,ST2(3,JJ),KFLAG,EPTTN) 

			IF(IOPT2.EQ.0) THEN
			EDAT(1+JJ) = -DD*YOUNG
			ENDIF					

			ENDIF

		ENDIF
		ENDDO

C	--------------
	DO I = 1,NOUT
	VALV = EDAT(I)
	NUM = I
	CALL RELFILL('OGSS',VALV,NUM,ISS,1)
	NUM = I+NOUT
	CALL RELFILL('OGSS',VALV,NUM,ISS,1)
	ENDDO			
C	--------------

	ENDDO

	DEALLOCATE(EDAT)


	RETURN
	END
C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE SPLOUT(ID,SD,DISP,DISPI,NEQ,SD2,SDWOK)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=================================================================
	
      COMMON /FLAG/  IFPRI,ISPRI,IFPLO,IFREF,IFEIG,ITASK,IFFLAG

	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM

C	NEW SPRING SUPPORT SONGSAK JUL2006
	COMMON /SPBC/ NSS,NLSS


	DIMENSION ID(NSF,NSN),SD(6,NSN),DISP(NEQ),DISPI(NEQ),DIP(NEQ)
	DIMENSION SD2(42,NSS),SDWOK(30,NSS)
	DIMENSION ST2(7,6),SDW(5,6)


	ALLOCATABLE EDAT(:)
	CALL LOCATN('OLSS',KLSS,NOUT2,NOUT1,2)
	NOUT = NOUT2/2
	ALLOCATE(EDAT(NOUT))


	DO IEQ = 1,NEQ
	DIP(IEQ) = DISP(IEQ)
	IF(ITASK.EQ.2) DIP(IEQ) = DISP(IEQ)+DISPI(IEQ) 
	ENDDO


	DO ISS = 1+NSS,NSS+NLSS
	CALL CALFOS(SD2(1,ISS),SDWOK(1,ISS),ST2,SDW)
		DO JJ = 1,NSF
		IF (JJ.LE.6) THEN
		II = ST2(1,JJ)

		EDAT(1) = FLOAT(II)    !SUPPORT NODE NO.

		IOPT2 = ST2(6,JJ)
		IEQ   = ID(JJ,II)
		YOUNG = SD(JJ,II)

			IF(IEQ.GT.0) THEN
			DD = DIP(IEQ)

			R21   = ST2(2,JJ)
			YOUN2 = YOUNG*R21
			FY    = ST2(3,JJ)
			DMAX  = ST2(4,JJ) 
			QFY   = ST2(5,JJ) 

			EPSP  = SDW(1,JJ)
			SIGP  = SDW(2,JJ) 
			EPSTN = SDW(3,JJ) 
			EPTTN = SDW(4,JJ) 

			CALL SPGPAS(EPSP,SIGP,DD,EDAT(1+JJ),YOUNG,YOUN2,
	1				    EPSTN,ST2(3,JJ),KFLAG,EPTTN) 

			IF(IOPT2.EQ.0) THEN
			EDAT(1+JJ) = -DD*YOUNG
			ENDIF					

			ENDIF

		ENDIF
		ENDDO
		III = ISS - NSS

C	--------------
	DO I = 1,NOUT
	VALV = EDAT(I)
	NUM = I
	CALL RELFILL('OLSS',VALV,NUM,III,1)
	NUM = I+NOUT
	CALL RELFILL('OLSS',VALV,NUM,III,1)
	ENDDO			
C	--------------

	ENDDO


	DEALLOCATE(EDAT)

	RETURN
	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE MODOUT(ID,DISP,IMOD)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON A(9000000),IA(9000000)


	DIMENSION ID(NSF,1),D(9),DISP(1),EDAT(9)



	CALL INTFILL('EIGM',NFILM,1,5,0) !FILE FOR MODE SHAPE


      DO 1250  ISN=1,NSN
	CALL CLEARA (D,9)

      DO 1210  ISF=1,NSF
      IPO = IDOF(ISF)
      IEQ = ID(ISF,ISN)
	IF (IEQ.NE.0)  D(IPO) = DISP(IEQ)
 1210	CONTINUE

      IF (NLS.GT.0) CALL LOCRES (ID,IA(LDS),A(LDC),D,D,D,D,D,NSF,ISN,3)
	
	DO I = 1,9
	EDAT(I) = D(I)
	ENDDO

	NRC = ISN + NSN*(IMOD-1)  !RECORD NUMBER
C	--------------
	WRITE(NFILM,REC=NRC) EDAT(1:9)
C	--------------


 1250 CONTINUE
	


	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================
	SUBROUTINE FIXSTOR(ILC,IEG,IEL,FIXEND,NEF,FACT,IND,TYP)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
	CHARACTER*3 IND
	CHARACTER*4 TYP
C     ----------------------------------------------------------------
	DIMENSION FIXEND(1)
	ALLOCATABLE AA(:)

	IF(ILC.LE.0) RETURN

	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRF',N2   ,2 ,IEG,0) !
	CALL INTFILL('OGRF',NFL2 ,12,IEG,0) !FOR FIXEND FORCES
	ALLOCATE(AA(N2))


	NRC = IEL + NELE*(ILC-1)

	IOPT = -1
	IF(IND.EQ.'RED') IOPT = 0
	IF(IND.EQ.'WRT') IOPT = 1
	IF(IND.EQ.'ADD') IOPT = 2
	IF(IND.EQ.'INI') IOPT = 3
	IF(IOPT.EQ.-1) RETURN

	NRC = 0
	IRO = IEL + NELE*(ILC-1)
	IF(TYP.EQ.'VARY') NRC = 2*IRO-1          !LINE NUMBER 2*N-1
	IF(TYP.EQ.'CONT') NRC = 2*IRO-0		     !LINE NUMBER 2*N
	IF(NRC.EQ.0) RETURN


	SELECTCASE(IOPT)

	CASE(0)  !READ
	AA(1:N2) = 0.0
	READ(NFL2,REC=NRC,ERR=10) AA(1:N2)
10	FIXEND(1:NEF) = AA(1:NEF)*FACT

	CASE(1)  !WRITE
	AA(1:N2) = 0.0
	READ(NFL2,REC=NRC,ERR=20) AA(1:N2)
20	AA(1:NEF) = FIXEND(1:NEF)*FACT
	WRITE(NFL2,REC=NRC) AA(1:N2)

	CASE(2)  !ADD
	AA(1:N2) = 0.0
	READ(NFL2,REC=NRC,ERR=30) AA(1:N2)
30	AA(1:NEF) = AA(1:NEF) + FIXEND(1:NEF)*FACT
	WRITE(NFL2,REC=NRC) AA(1:N2)

	CASE(3)  !INITIALIZE
	AA(1:N2) = 0.0D0
	WRITE(NFL2,REC=NRC) AA(1:N2)

	ENDSELECT


	DEALLOCATE(AA)


      RETURN
      END

C	=====================================================================
C	=================================================================
	SUBROUTINE FIXSTOR_OFFSHORE(ILC,IEG,IEL,FIXEND,NEF,FACT,IND,TYP)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
	CHARACTER*3 IND
	CHARACTER*4 TYP
C     ----------------------------------------------------------------
	DIMENSION FIXEND(1)
	ALLOCATABLE AA(:)

	IF(ILC.LE.0) RETURN

	CALL INTFILL('OGRP',NELE ,4 ,IEG,0) !
	CALL INTFILL('OGRF',N2   ,2 ,IEG,0) !
	CALL INTFILL('OGRF',NFL6 ,16,IEG,0) !OFFSHORE LOAD CASE BY TOEY
	ALLOCATE(AA(N2))


	NRC = IEL + NELE*(ILC-1)

	IOPT = -1
	IF(IND.EQ.'RED') IOPT = 0
	IF(IND.EQ.'WRT') IOPT = 1
	IF(IND.EQ.'ADD') IOPT = 2
	IF(IND.EQ.'INI') IOPT = 3
	IF(IOPT.EQ.-1) RETURN

	NRC = 0
	IRO = IEL + NELE*(ILC-1)
	IF(TYP.EQ.'VARY') NRC = 2*IRO-1          !LINE NUMBER 2*N-1
	IF(TYP.EQ.'CONT') NRC = 2*IRO-0		     !LINE NUMBER 2*N
	IF(NRC.EQ.0) RETURN

	SELECTCASE(IOPT)

	CASE(0)  !READ
	AA(1:N2) = 0.0
	READ(NFL6,REC=NRC,ERR=10) AA(1:N2)
10	FIXEND(1:NEF) = AA(1:NEF)*FACT

	CASE(1)  !WRITE
	AA(1:N2) = 0.0
	READ(NFL6,REC=NRC,ERR=20) AA(1:N2)
20	AA(1:NEF) = FIXEND(1:NEF)*FACT
	WRITE(NFL6,REC=NRC) AA(1:N2)

	CASE(2)  !ADD
	AA(1:N2) = 0.0
	READ(NFL6,REC=NRC,ERR=30) AA(1:N2)
30	AA(1:NEF) = AA(1:NEF) + FIXEND(1:NEF)*FACT
	WRITE(NFL6,REC=NRC) AA(1:N2)

	CASE(3)  !INITIALIZE
	AA(1:N2) = 0.0D0
	WRITE(NFL6,REC=NRC) AA(1:N2)

      ENDSELECT
      
      DEALLOCATE(AA)

      RETURN
      END
C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE FRMBEP (RG,VR,IEG,IEL,ANG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION VR(3),VS(3),VT(3),TRANS(7,7)
	DIMENSION RL(7,2),RG(7,2)

	
	RANG = ANG

	CALL FMVEVR (VR,VS,VT)
	CALL ROMBAC (VR,VS,VT,RANG)

	TRANS = 0.0
	DO I = 1,3
	TRANS(I,1) = VR(I)
	TRANS(I,2) = VS(I)
	TRANS(I,3) = VT(I)
	TRANS(I+3,4) = VR(I)
	TRANS(I+3,5) = VS(I)
	TRANS(I+3,6) = VT(I)
	ENDDO

	RL = 0.0
	DO INM = 1,2

	DO IFF = 1,6
	DO JFF = 1,6
	RL(IFF,INM) = RL(IFF,INM) + TRANS(JFF,IFF)*RG(JFF,INM)
	ENDDO
	ENDDO

	ENDDO

	NEF = 14
	CALL FIXSTOR(ILCN,IEG,IEL,RL,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR(ILCC,IEG,IEL,RL,NEF,1.0D0,'ADD','CONT')


	RETURN

	END

C	=====================================================================
C	=====================================================================
	SUBROUTINE FRMBEP_OFFSHORE (RG,VR,IEG,IEL,ANG)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION VR(3),VS(3),VT(3),TRANS(7,7)
	DIMENSION RL(7,2),RG(7,2)

	
	RANG = ANG

	CALL FMVEVR (VR,VS,VT)
	CALL ROMBAC (VR,VS,VT,RANG)

	TRANS = 0.0
	DO I = 1,3
	TRANS(I,1) = VR(I)
	TRANS(I,2) = VS(I)
	TRANS(I,3) = VT(I)
	TRANS(I+3,4) = VR(I)
	TRANS(I+3,5) = VS(I)
	TRANS(I+3,6) = VT(I)
	ENDDO

	RL = 0.0
	DO INM = 1,2

	DO IFF = 1,6
	DO JFF = 1,6
	RL(IFF,INM) = RL(IFF,INM) + TRANS(JFF,IFF)*RG(JFF,INM)
	ENDDO
	ENDDO

	ENDDO

	NEF = 14
	CALL FIXSTOR_OFFSHORE(ILCN,IEG,IEL,RL,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR_OFFSHORE(ILCC,IEG,IEL,RL,NEF,1.0D0,'ADD','CONT')


	RETURN

	END

C	=====================================================================
	SUBROUTINE FIXSHE (RG,IEG,IEL,NNO,NDT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================
C	LOADCASE
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION RG(NDT,NNO),FIX(6,NNO)


	DO IN = 1,NNO
	FIX(1:6,IN) = 0.0D0
	FIX(1:NDT,IN) = RG(1:NDT,IN)
	ENDDO

	NEF = 6*NNO
	CALL FIXSTOR(ILCN,IEG,IEL,FIX,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR(ILCC,IEG,IEL,FIX,NEF,1.0D0,'ADD','CONT')


	RETURN

      END
C	=====================================================================
	SUBROUTINE FIXSHE_OFFSHORE (RG,IEG,IEL,NNO,NDT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================
C	LOADCASE
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION RG(NDT,NNO),FIX(6,NNO)


	DO IN = 1,NNO
	FIX(1:6,IN) = 0.0D0
	FIX(1:NDT,IN) = RG(1:NDT,IN)
	ENDDO

	NEF = 6*NNO
	CALL FIXSTOR_OFFSHORE(ILCN,IEG,IEL,FIX,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR_OFFSHORE(ILCC,IEG,IEL,FIX,NEF,1.0D0,'ADD','CONT')


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE FIXMRE (RG,IEG,IEL,NEF,NNO)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================

C	LOADCASE
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION RG(NEF)

	CALL FIXSTOR(ILCN,IEG,IEL,RG,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR(ILCC,IEG,IEL,RG,NEF,1.0D0,'ADD','CONT')

	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE FIXSOL (RG,IEG,IEL,NEF,NNO)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================

C	LOADCASE
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION RG(NEF)

	CALL FIXSTOR(ILCN,IEG,IEL,RG,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR(ILCC,IEG,IEL,RG,NEF,1.0D0,'ADD','CONT')


	RETURN

      END
      
C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE FIXSOL_OFF (RG,IEG,IEL,NEF,NNO)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================

C	LOADCASE
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION RG(NEF)

	CALL FIXSTOR_OFFSHORE(ILCN,IEG,IEL,RG,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR_OFFSHORE(ILCC,IEG,IEL,RG,NEF,1.0D0,'ADD','CONT')


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE FIXTRS (RG,IEG,IEL,NEF,NNO)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	=====================================================================

C	LOADCASE
	COMMON /LCSS/ ILCN,ILCC

	DIMENSION RG(NEF)


	CALL FIXSTOR(ILCN,IEG,IEL,RG,NEF,1.0D0,'ADD','VARY')
	CALL FIXSTOR(ILCC,IEG,IEL,RG,NEF,1.0D0,'ADD','CONT')


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE LCHEADER(NLC,IOPT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
      CHARACTER*4 IOPT
	CHARACTER*200 NAME
	CHARACTER*200 LHDSTD,LHDCOM
	

      COMMON /INOU/ ITI,ITO,ISO,NDATI,NPLOT,NKFAC,NELEM,
     1              IFPR(10),IFPL(10)

	COMMON /LHEADER/ LHDSTD(500),LHDCOM(500)


	INF = -1
	IF(IOPT.EQ.'STND') INF = 0 !STANDARD LOAD
	IF(IOPT.EQ.'COMB') INF = 1 !COMBINATION LOAD
	! ERROR FUNCTION INF=-1 RETURN
	IF(INF.EQ.-1) RETURN

	SELECTCASE(INF)

	CASE(0)
	! NLC=LCS
	! NLC=NUMBER OF LOAD CASE
	DO ILC = 1,NLC
	READ(ITI,'(A200)') NAME
	LHDSTD(ILC) = NAME
	ENDDO

	CASE(1)
	DO ILC = 1,NLC
	READ(ITI,'(A200)') NAME
	LHDCOM(ILC) = NAME
	ENDDO

	ENDSELECT

C	SELECTCASE(ILC)
C	CASE(1)
C	NAME = 'LOAD CASE 1'
C	CASE(2)
C	NAME = 'LOAD CASE 2'
C	CASE(3)
C	NAME = 'LOAD CASE 3'
C	CASE(4)
C	NAME = 'LOAD CASE 4'
C	CASE(5)
C	NAME = 'LOAD CASE 5'
C	CASE(6)
C	NAME = 'LOAD CASE 6'
C	CASE(7)
C	NAME = 'LOAD CASE 7'
C	CASE(8)
C	NAME = 'LOAD CASE 8'
C	CASE(9)
C	NAME = 'LOAD CASE 9'
C	CASE(10)
C	NAME = 'LOAD CASE 10'
C	ENDSELECT


C	DO ILC = 1,NLC
C	NAME = LHDSTD(ILC)
C	LENGTH = LEN_TRIM(NAME)
C	WRITE(*,100) NAME(1:LENGTH)
C	ENDDO
C100	FORMAT(A,'End')
C	PAUSE


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE PRNLCHD(NAME,LENGTH,ILC,INM,IND)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
	CHARACTER*200 NAME
	CHARACTER*200 LHDSTD,LHDCOM
	

	COMMON /LHEADER/ LHDSTD(500),LHDCOM(500)


	SELECTCASE(INM)

	CASE(0)  !STANDARD
	IF(IND.EQ.0) THEN		!MEAN THAT PRINT LOADCASE	
	NAME = LHDSTD(ILC)
	ILC = 1
	ELSEIF(IND.EQ.1) THEN		!MEAN THAt PRINT LOAD STEP
	NAME = LHDSTD(1)
	ENDIF

	CASE(1)  !COMBINATION
	IF(IND.EQ.0) THEN		!MEAN THAT PRINT LOADCASE			
	NAME = LHDCOM(ILC)
	ILC = 1
	ELSEIF(IND.EQ.1) THEN		!MEAN THAt PRINT LOAD STEP
	NAME = LHDCOM(1)
	ENDIF

	ENDSELECT


	LENGTH = LEN_TRIM(NAME)


C	DO ILC = 1,LCS
C	NAME = LHEADER(ILC)
C	LENGTH = LEN_TRIM(NAME)
C	WRITE(*,100) NAME(1:LENGTH)
C	ENDDO
C100	FORMAT(A,'End')

	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================	
	SUBROUTINE PRNGPHD(NAME,LENGTH,IGP)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
	CHARACTER*200 NAME
	CHARACTER*200 LHDGRP

	COMMON /GHEADER/ LHDGRP(500)
	
C	RETURN GID GROUP HEADER

	NAME = LHDGRP(IGP)
	LENGTH = LEN_TRIM(NAME)


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	
	SUBROUTINE TENDONMAP(ITD,ITI,IEGT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------
C	TENDON NAME MAPPING FOR CONSTRUCTION ANALYSIS
C     ----------------------------------------------------------------
	CHARACTER*200 NAME
	CHARACTER*200 LHDGRP_T

	COMMON /THEADER/ LHDGRP_T(1000,5)


	READ(ITI,'(A200)') NAME
	LHDGRP_T(ITD,IEGT) = NAME


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================	
	SUBROUTINE PRNTHD(NAME,LENGTH,ITD,IEGT)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------
C	RETURN TENDON NAME HEADER FOR CONSTRUCTION ANALYSIS
C     ----------------------------------------------------------------
	CHARACTER*200 NAME
	CHARACTER*200 LHDGRP_T

	COMMON /THEADER/ LHDGRP_T(1000,5)
	

	NAME = LHDGRP_T(ITD,IEGT)
	LENGTH = LEN_TRIM(NAME)


	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
	SUBROUTINE CHECKTDNAME(TNAME,ITD,IEGT,ITFOUND)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C     ----------------------------------------------------------------
C	COMPARE TENDON NAME
C      TNAME = LHDGRP_T(ITEND,IEGT)  ?
C     ITFOUND = 0 if not equal
C     ITFOUND = 1 if equal
C     ----------------------------------------------------------------
	CHARACTER*200 TNAME
	CHARACTER*200 NAME
	CHARACTER*200 LHDGRP_T
	CHARACTER*200 NAME1
	CHARACTER*200 NAME2

	COMMON /THEADER/ LHDGRP_T(1000,5)
	
	NAME = LHDGRP_T(ITD,IEGT)

      NAME1 = TRIM(NAME) 
      NAME2 = TRIM(TNAME)
      
      ITFOUND = 0
      IF(NAME1.EQ.NAME2) ITFOUND = 1
      
	RETURN

	END

C	=====================================================================
C	=====================================================================
C	=====================================================================
      SUBROUTINE STORXYZ (NSC,NSN) 
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)

C	-----------------------------------
C     STORE NODAL COORDINATES ... SONGSAK OCT2019
C	-----------------------------------

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON A(9000000),IA(9000000)

C-----TRANSFER COORDINATE DATA-----
	IXY = LXY
	DO 20 I = 1,NSC
	DO 10 J = 1,NSN
      CALL RELFILL('@XYZ',A(IXY),I,J,1)  !STORE HERE NODAL COORDINATE
	IXY = IXY+1
10	CONTINUE
20	CONTINUE

	RETURN
      END

C	=======================================================================
C	=======================================================================
C	=======================================================================
      SUBROUTINE STORLRID
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)

C	-----------------------------------
C     STORE SUPPORT CONDITION ... SONGSAK OCT2019
C     **WARNING ... NO CONSIDERATION SKEWED SUPPORT**
C	-----------------------------------
      COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM
      COMMON /NUMB2/ IDOFB(9)
      
      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

C	==================================================================
C	ADDED BY SONGSAK APR2006 REACTION	
	COMMON /REACT/ LRC,LRCT,MFQ,LRID
C	==================================================================
      
      COMMON A(9000000),IA(9000000)

      ALLOCATABLE IDRCT(:,:),KDRCT(:)
      
      DIMENSION MAPP(9)

C     EXTRACT FREE NODAL DOF      
      NNDF = 0
      DO I = 1,9
          IF(IDOFB(I).EQ.0) THEN
              NNDF = NNDF + 1
              MAPP(NNDF) = I
          ENDIF
      ENDDO
      
       
      ALLOCATE(IDRCT(10,NSN),KDRCT(9))
      IDRCT = 0 !INITIALIZE
      KDRCT = 0
      
      NSUP = 0
      IRID = LRID
      DO ISN = 1,NSN
          DO ISF = 1,NSF
              IBC = IA(IRID)    !GET FIXED ID HERE
              IF(IBC.GT.0) IBC = 1
	        KDRCT(IDOF(ISF)) = IBC
              IRID = IRID+1
          ENDDO
          
          ICHECK = SUM(KDRCT(MAPP(1:NNDF)))
          IF(ICHECK.GT.0) THEN
              NSUP = NSUP + 1
              IDRCT(1      ,NSUP) = ISN
              IDRCT(1+1:9+1,NSUP) = KDRCT(1:9)
          ENDIF
      ENDDO
      

C     ALLOCATE SPACE FOR STORE BOUNDARY CONDITION      
      CALL DEFNINT('@SUP',KRID,10,NSUP) 
      
      DO ISUP = 1,NSUP
          DO ISAT = 1,10
              CALL INTFILL('@SUP',IDRCT(ISAT,ISUP),ISAT,ISUP,1)  !STORE BOUNDARY CONDITION 
          ENDDO
      ENDDO
      
      
      DEALLOCATE(IDRCT,KDRCT)      
      
      
	RETURN
      END

C	=======================================================================
C	=======================================================================
C	=======================================================================
	SUBROUTINE KAKOUT(ID,DISP)
	IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
C	----------------------------------------------------------------
	COMMON /NUMB/ HED(20),MODEX,NRE,NSN,NEG,NBS,NLS,NLA,
     +              NSC,NSF,IDOF(9),LCS,ISOLOP,LSYMM

      COMMON /LOCA/ LID,LDS,LEL,LDC,LXY,LCH,LNU,LMP,LGP,LMS,LGS,
     1              LCO,LEX,LLM,LES,LEC,LED,LEI,LEE,LMA,LLF,LLV,
     2              LRE,LDI,LDL,LDT,LDK,LER,LEV,LTT,LWV,LAR,LBR,
     3              LVE,LDD,LRT,LBU,LBC,LVL,LAL,LEF,LDU,LPR,LLO,
	4              LRV,LRT1,LRET,LRET1,LDM,LDPT,LVL1,LMV,LXI,LCM,LCC,
	5			    LCN,LDIM,LFRE,LSFC,LLOF

      COMMON A(9000000),IA(9000000)


	DIMENSION ID(NSF,1),D(9),DISP(1),REAC(3)

	ALLOCATABLE EDAT(:)
	CALL LOCATN('ONDS',KDISP,NOUT2,NOUT1,2)
	NOUT = NOUT2/2
	ALLOCATE(EDAT(NOUT))

	REAC(1:3) = 0.0d0

      DO 1250  ISN=1,NSN
	CALL CLEARA (D,9)

      DO 1210  ISF=1,NSF
      IPO = IDOF(ISF)
      IEQ = ID(ISF,ISN)
	IF (IEQ.NE.0)  D(IPO) = DISP(IEQ)

	IF(ISF.LE.3) THEN
	REAC(ISF) = REAC(ISF) + D(IPO)
C	IF(ABS(D(IPO)).GT.ABS(REAC(ISF))) THEN
C	REAC(ISF) = D(IPO)
C	ENDIF
	ENDIF

 1210	CONTINUE


C	WRITE(*,'(I4,3E12.4)') ISN,D(1:3)
	

 1250 CONTINUE
	
	DEALLOCATE(EDAT)

	WRITE(*,*) REAC(1:3)
	PAUSe
	

	RETURN

	END

C	=================================================================
C	=================================================================
C	=================================================================

